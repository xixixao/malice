ometa BSOMetaParser extends BSDentParser
  lineComment    = fromTo('# ', '\n')
  blockComment   = fromTo('#>', '<#')
  space          = ' ' | spacedent | lineComment | blockComment
  blankLine      = ' '* (lineComment | blockComment ' '* '\n')
                 | ^blankLine
  nameFirst      = '_' | '$' | letter
  bareName       = <nameFirst (nameFirst | digit)*>
  name           = spaces bareName
  hexValue :ch                                                         -> '0123456709abcdef'.indexOf ch.toLowerCase()
  hexDigit       = char:x {this.hexValue(x)}:v &{v >= 0}               -> v
  escapedChar    = <'\\' ( 'u' hexDigit hexDigit hexDigit hexDigit
                         | 'x' hexDigit hexDigit
                         | char                                   )>:s -> unescape s
                 | char
  charSequence   = '"'  ( !'"' escapedChar)*:xs  '"'                   -> string = programString xs.join ''
                                                                          @usedTokens.add string
                                                                          ['App', 'token',   string]
  string         = '\'' (!'\'' escapedChar)*:xs '\''                   -> ['App', 'exactly', programString xs.join '']
  number         = <'-'? digit+>:n                                     -> ['App', 'exactly', n]
  keyword :xs    = token(xs) !letterOrDigit                            -> xs
  args           = '(' listOf('hostExpr', ','):xs ")"                  -> xs
                 | empty                                               -> []
  application    = "^"          name:rule args:as                      -> ['App', "super",        "'" + rule + "'"].concat as
                 | name:grm "." name:rule args:as                      -> ['App', "foreign", grm, "'" + rule + "'"].concat as
                 |              name:rule args:as                      -> ['App', rule].concat as
  hostExpr        = BSSemActionParser.simpleExp(@locals.values())
  closedHostExpr  = BSSemActionParser.delimSemAction(@locals.values())
  openHostExpr :p = BSSemActionParser.semAction(p, @locals.values())
  semAction      = closedHostExpr:x                                    -> ['Act', x]
  arrSemAction   = "->" linePos:p openHostExpr(p):x                    -> ['Act', x]
  semPred        = "&" closedHostExpr:x                                -> ['Pred', x]
                 | "!" closedHostExpr:x                                -> ['Not', ['Pred', x]]
  expr :p        = setdent(p) expr5:x {this.redent()}                  -> x
  expr5          = expr4(true):x ("|" expr4(true))+:xs                 -> ['Or',  x].concat xs
                 | expr4(true):x ("||" expr4(true))+:xs                -> ['XOr', x].concat xs
                 | expr4(false)
  expr4 :ne      =       expr3*:xs arrSemAction:act                    -> ['And', ['Set', 'at', ['IdxConsBy', ['And'].concat(xs)]], act]
                 | &{ne} expr3+:xs                                     -> ['And'].concat xs
                 | !{ne} expr3*:xs                                     -> ['And'].concat xs
  optIter :x     = '*'                                                 -> ['Many',  x]
                 | '+'                                                 -> ['Many1', x]
                 | '?'                                                 -> ['Opt',   x]
                 | empty                                               -> x
  optBind :x     = ':' name:n                                          -> @locals.add n; ['Set', n, x]
                 | empty                                               -> x
  expr3          = ":" name:n                                          -> @locals.add n; ['Set', n, ['App', 'anything']]
                 | (expr2:x optIter(x) | semAction):e optBind(e)
                 | semPred
  expr2          = "!" expr2:x                                         -> ['Not',       x]
                 | "&" expr1:x                                         -> ['Lookahead', x]
                 | expr1
  expr1          = application
                 | ( keyword('undefined') | keyword('nil')
                   | keyword('true')      | keyword('false') ):x       -> ['App', 'exactly', x]
                 | spaces (charSequence | string | number)
                 | "["  expr(0):x "]"                                  -> ['Form',      x]
                 | "<"  expr(0):x ">"                                  -> ['ConsBy',    x]
                 | "@<" expr(0):x ">"                                  -> ['IdxConsBy', x]
                 | "("  expr(0):x ")"                                  -> x
  ruleName       = bareName
  rule           = &(ruleName:n) {@locals = new Set}
                    linePos:p setdent(p + 1) rulePart(n):x
                     (nodent(p) rulePart(n))*:xs {this.redent()}       -> ['Rule', n, this.locals.values(),
                                                                           ['Or', x].concat xs]
  rulePart :rn   = ruleName:n &{n == rn} 
                   (expr4(false):b1
                    ( spaces linePos:p '=' expr(p):b2 -> ['And', b1, b2]
                    | empty                           -> b1
                    ) | error("Error in syntax of rule #{n}") )
  grammar        = (inspace*:ss -> 1 + ss.length):ip {@usedTokens = new Set}
                   keyword('ometa') name:n
                   ( keyword('extends') name | empty -> 'OMeta' ):sn
                   moredent(ip)
                     linePos:p rule:r
                     (nodent(p) rule)*:rs                               BSOMetaOptimizer.optimizeGrammar(
                                                                            ['Grammar', n, sn, @usedTokens.values(), r].concat rs
                                                                        )
