#
# translation.metacoffee
#
#   Translates annotated AST into Three Address Code
#

errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'
{Node, Executes, Value, Reference, FunctionNode,
 SimpleType, FunctionType, ArrayType, ErrorType, types} = require './nodes'

module.exports = (OMeta, OMLib) -> translate: (source, ast) ->

  ometa MAliceTranslator
    trans     :node = transNode(node, node)
    transNode :node = [:t (!{@[t]?} anything* {node} | prepend([node]) apply(t)):ans] -> ans
    head = empty {log @input.head()} empty
         | {log "There's nothing here"} empty

    Program :node :pos :scope enterScope(scope) trans:declarations trans:initializations
      ->  global: concat declarations, initializations
          stack: concat @functions...

    Function :node :pos :type :name :returnType [trans*:args] :scope {
      for freeName, freeNode of scope.frees
        args.push ['Argument', [newFreeName = @declare(null, freeName)], freeNode.type()]
        scope.freeNames[freeName] = newFreeName
      log name, scope.frees, scope.freeNames
    } trans:body
      ->  name = @declare(node, name)
          concat [['Label', name], ['Begin']], args, body, [['End', name]]

    Argument :node :pos :type :name
      ->  ['Argument', name, type]

    Block :node :pos :returns :scope enterScope(scope) trans:declarations trans:statements exitScope
      ->  concat declarations, statements

    Declarations :node :pos trans*:ds
      ->  for d in ds when !d.simple?
            @functions.push d
          d[0] for d in ds when d.simple?

    Variable :node :pos :type :name
      ->  decl = [['Variable', name = @declare(node, name), type]]
          decl.simple = yes
          decl

    Array :node :pos :type :name trans:size
      ->  [body, result] = size
          decl = concat body, [['Array', @declare(node, name), type, result]]
          decl.simple = yes
          decl

    Statements :node :pos :returns trans*:ss
      -> concat ss...

    Skip :node :pos :returns
      -> []

    Assignment :node :pos :returns ['Element' :elempos
                          :type trans:array trans:index] trans:value
      ->  [indexbody, indexresult] = index
          [arraybody, arrayresult] = array
          [body, result] = value
          concat body, arraybody, indexbody, [
            ['ArrayAssignment', arrayresult, indexresult, result]
          ]

    Assignment :node :pos :returns trans:assignable trans:value
      ->  [body, result] = value
          [_, into] = assignable
          concat body, [
            ["Assignment", into, result]
          ]

    Decrement :node :pos :returns trans:variable
      ->  [_, into] = variable
          [['Decrement', into]]

    Increment :node :pos :returns trans:variable
      ->  [_, into] = variable
          [['Increment', into]]

    Output :node :pos :returns trans:value
      ->  [body, result] = value
          concat body, [
            ['Output', result, node[3].type()]
          ]

    Call :node :pos :detail trans:fun trans*:args
      ->  paramBodies = []
          paramResults = []
          paramPops = []
          for arg in args
            [body, result] = arg
            paramBodies = concat paramBodies, body
            paramResults.unshift ['Param', result]
          scope = node[3].original.scope()
          for freeName, freeNode of scope.frees
            paramResults.unshift ['Param', @currentScope.getNameOf(freeNode.name())[0]]
          [_, name] = fun
          call = concat paramBodies, paramResults
          for freeName, freeNode of scope.frees
            paramPops.push ['ParamPop', @currentScope.getNameOf(freeNode.name())[0]]
          [_, name] = fun
          if detail is false
            concat call, [
              ['Call', name, args.length]
            ], paramPops
          else
            [concat(call, [
              ['CallAssignment', callResult = @newTemp(), name, args.length]
            ], paramPops), callResult]


    Return :node :pos :returns trans:value
      ->  [body, result] = value
          concat body, [
             ['Return', result]
          ]

    Input :node :pos :returns trans:variable
      ->  [_, into] = variable
          [['Read', variable, node[3].type()]]

    If :node :pos :returns trans:cond trans:ifBody trans:elseBody
      ->  [condbody, condresult] = cond
          concat condbody, [
            ['IfFalse', condresult, elseLabel = @newLabel()]
          ], ifBody, [
            ['Jump', endLabel = @newLabel()]
            ['Label', elseLabel]
          ], elseBody, [
            ['Label', endLabel]
          ]

    Until :node :pos :returns trans:cond trans:body
      ->  [condbody, condresult] = cond
          concat condbody, [
            ['Label', whileLabel = @newLabel()]
            ['IfTrue', condresult, endLabel = @newLabel()]
          ], body, [
            ['Jump', whileLabel]
            ['Label', endLabel]
          ]

    Logic :node :pos :type :op trans:b1 trans?:b2
      ->  @translateExpression op, b1, b2

    Compare :node :pos :type :op trans:e1 trans:e2
      ->  @translateExpression op, e1, e2

    Arithmetic :node :pos :type :op trans:e1 trans?:e2
      ->  @translateExpression op, e1, e2

    Unary :node :pos :type :op trans:e
      ->  @translateExpression op, e

    Dereference :node :pos :type :name anything*
      ->  [name, isPointer] = @currentScope.getNameOf(name)
          name = [name] if isPointer
          [[], name]

    Element :node :pos :type trans:array trans:index
      ->  [indexbody, indexresult] = index
          [arraybody, arrayresult] = array
          [concat(indexbody, arraybody,
            [['ArrayAccess', temp = @newTemp(), arrayresult, indexresult]]
          ), temp]

    Value :node :pos :type :v
      ->  @translateValue v, type

    Number :node :pos :type :n
      ->  @translateValue n, type

    Letter :node :pos :type :ch
      ->  @translateValue ch, type

    Sentence :node :pos :type :string
      ->  @translateValue string, type

    enterScope :scope
      ->  @currentScope = scope

    exitScope
      ->  @currentScope = @currentScope.outer

    initialize
      ->  @labelCounter = 0
          @tempCounter = 0
          @functions = []
          @names = {}

  MAliceTranslator::translateExpression = (op, e1, e2) ->
    [e1body, e1result] = e1
    [e2body, e2result] = e2 if e2?
    result = @newTemp()
    [concat(e1body, e2body ? [], [
      concat ['ImmAssignment', result, op, e1result], if e2? then [e2result] else []
    ]), result]

  MAliceTranslator::translateValue = (v, type) ->
    [[['ValAssignment', temp = @newTemp(), v, type]], temp]

  MAliceTranslator::newLabel = ->
    "L" + @labelCounter++

  MAliceTranslator::newTemp = ->
    "t" + @tempCounter++

  MAliceTranslator::declare = (node, name) ->
    if name is "hatta" and node?.scope?().outer and not node?.scope?().outer.outer?
      return "main"
    origName = name
    if @names[name]
      name = origName + Math.floor(Math.random() * 999) while @names[name]
    @names[name] = true
    node?.mangledName = name
    name

  MAliceTranslator.match ast, "trans", undefined, (m, i) -> console.error "ERROR while traversing AST in translator"
