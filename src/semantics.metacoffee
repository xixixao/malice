dump = require './jsDump'

module.exports = (OMeta, OMLib) -> analyze: (ast) ->

  error = (err) ->
    console.error "Semantic error: \n  " + err

  typeError = (name, expected, actual) ->
    error "Type mismatch for #{name}, expected '#{expected.toString()}', got '#{actual.toString()}'"

  log = (xs...) ->
    console.log dump.parse x for x in xs

  ometa MAliceSemantics
    trans = [:t apply(t):ans] -> ans

    Program createScope:scope trans:declarations

    Function :name trans:returnType trans:args 
             createScope:scope {scope.addAll args; scope.returns returnType} trans:body exitScope
      ->
        @declare new FunctionIdentifier name, returnType, args

    Arguments trans*

    Argument :name trans:type
      ->
        new Reference name, type

    Block createScope:scope trans:declarations trans:statements exitScope

    Declarations trans*

    Variable :name trans:type trans:value
      ->
        @declare new Reference name, type

    Array :name trans:size trans:itemType
      ->
        typeError "array size", types.number, size.type unless size.type.equals types.number
        @declare new Reference name, new ArrayType itemType

    Skip
      ->
    Assignment trans:assignable trans:value
      ->
        unless assignable.type.equals value.type
          error "Wrong type in assignment, left hand side has type #{assignable.type.toString()}, right hand side has type #{value.type.toString()}"

    Decrement trans:variable
      ->
        typeError "decrement", types.number, variable.type unless variable.type.equals types.number

    Increment trans:variable
      ->
        typeError "increment", types.number, variable.type unless variable.type.equals types.number

    Output trans:value
      ->
        error "Array of #{value.type.itemType} has no printable representation" if value.type.isArray?

    Call trans:fun trans*:args
      ->
        typeError "function call", types.function, fun.type unless fun.isFunction?
        if args.length isnt fun.args.length
          error "Function #{fun.name} expects #{fun.args.length} arguments, got #{args.length} arguments"
        else
          for arg, i in args
            typeError "argument #{i+1}", fun.args[i].type, arg.type unless arg.type.equals fun.args[i].type
        new Value fun.returnType

    Return trans:value
      ->
        currentReturnType = @currentScope.returns()
        if currentReturnType.equals types.void
          error "Return statement inside void function" 
        else if not value.type.equals currentReturnType
          typeError "return statement", currentReturnType, value.type

    Input trans:variable
      ->
        typeError "input", [types.number, types.letter, types.sentence].join(' or '), variable.type if variable.isFunction? or variable.type.isArray?

    If trans:cond trans trans
      ->
        typeError "condition", types.boolean, cond.type unless cond.type.equals types.boolean

    Until trans:cond trans
      ->
        typeError "loop condition", types.boolean, cond.type unless cond.type.equals types.boolean

    Statements trans*

    Spider trans:itemType
      ->
        new ArrayType itemType

    Type :label
      ->
        new Type label

    Logic :op trans:b1 trans?:b2
      ->
        error "Wrong type of operand, expected boolean" unless b1.type.equals types.boolean
        error "Wrong type of operand, expected boolean" if b2? and not b2.type.equals types.boolean
        new Value types.boolean

    Compare :op trans:e1 trans:e2
      ->
        error "Wrong type of operand, expected number or a letter" unless e1.type.equalsAny types.number, types.letter
        error "Wrong type of operand, expected number or a letter" unless e2.type.equalsAny types.number, types.letter
        error "Wrong type of operand, operands must have the same type" unless e1.type.equals e2.type
        new Value types.boolean

    Arithmetic :op trans:e1 trans?:e2
      ->
        error "Wrong type of operand, expected number" unless e1.type.equals types.number
        error "Wrong type of operand, expected number" if e2? and not e2.type.equals types.number
        new Value types.number

    Dereference :name
      ->
        @lookup name

    Element trans:array trans:index
      ->
        if not array.type.isArray?
          error "Trying to access element of nonarray"
          type = types.error
        else
          type = array.type.itemType
        error "Array's index must be a number" unless index.type.equals types.number
        new Value type

    Number :n
      ->
        new Value types.number

    Letter :ch
      ->
        new Value types.letter

    Sentence :string
      ->
        new Value types.sentence

    createScope
      ->
        outerScope = @currentScope
        @currentScope = new Scope outerScope, {}

    exitScope
      ->
        @currentScope = @currentScope.outer


  MAliceSemantics::declare = (identifier) ->
    alreadyDeclared = @currentScope.declaredInCurrent identifier
    if alreadyDeclared
      console.error "#{identifier.name} already declared in current scope"
    else
      @currentScope.add identifier
    #log "#{identifier.name} declared"
    identifier

  MAliceSemantics::lookup = (name) ->
    @lookupIn name, @currentScope

  MAliceSemantics::lookupIn = (name, scope) ->
    reference = scope.get name
    if reference?
      return reference
    else
      console.error "#{name} undeclared"
      return new Reference name, types.error

  class Node
    constructor: (@type) ->

  class Scope
    constructor: (@outer, @declarations) ->

    toString: ->
      "Scope#{dump.parse @declarations};#{@returnType}"

    add: (identifier) ->
      @declarations[identifier.name] = identifier

    addAll: (identifiers) ->
      @add identifier for identifier in identifiers

    returns: (type) ->
      if type?
        @returnType = type
      else
        @returnType ? @outer.returns()

    declaredInCurrent: (identifier) ->
      @declarations[identifier.name]?

    get: (name) ->
      @declarations[name] or @outer?.get name

  class Identifier # Could also hold a reference to the ASTnode that declares Identifier

  class Type extends Identifier
    constructor: (@label) ->
    equals: (t) ->
      @label is t.label or t.isError
    equalsAny: (ts...) ->
      ts.some (t) ->
        @equals t
      , this
    toString: ->
      @label

  class ErrorType extends Identifier
    isError: yes
    equals: (t) ->
      yes
    toString: ->
      "error"

  class Value extends Identifier
    constructor: (@type) ->

  class Reference extends Identifier
    constructor: (@name, @type) ->

  class FunctionIdentifier extends Identifier
    constructor: (@name, @returnType, @args, @scope) ->
    isFunction: yes
    type: new Type "function"

  class ArrayType extends Type
    constructor: (@itemType) ->
    isArray: yes
    equals: (t) ->
      t.isArray and @itemType.equals t.itemType
    toString: ->
      "spider #{@itemType}"

  types =
    number: new Type "number"
    letter: new Type "letter"
    sentence: new Type "sentence"
    boolean: new Type "boolean"
    function: new Type "function"
    void: new Type "void"
    error: new ErrorType

  MAliceSemantics.match ast, "trans", undefined, (m, i) -> error "ERROR in #{m}, #{i}"
