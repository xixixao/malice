dump = require './jsDump'

module.exports = (OMeta, OMLib) -> analyze: (ast) ->
  error = console.error

  log = (xs...) ->
    console.log x for x in xs

  ometa MAliceSemantics
    trans = [:t apply(t):ans] -> ans
    transMany = :array -> @prepend(array); (@apply('trans') for el in array)

    Program createScope:scope trans*:declarations

    Function :name trans:returnType transMany:args createScope:scope {scope.addAll args} trans:body exitScope
      ->
        @declare new FunctionIdentifier name, returnType, args

    Argument :name trans:type
      ->
        new Reference name, type

    Block createScope:scope trans* exitScope

    Variable :name trans:type trans:value
      ->
        @declare new Reference name, type

    Array :name trans:size trans:itemType
      ->
        error "Wrong type of size of array" unless size.type.equals types.number
        @declare new Reference name, new ArrayType itemType

    Skip
      ->
    Assignment trans:assignable trans:value
      ->
        error "Wrong type in assignment" unless assignable.type.equals value.type

    Decrement trans:variable
      ->
        error "Wrong type" unless variable.type.equals types.number
    Increment trans:variable
      ->
        error "Wrong type" unless variable.type.equals types.number
    Output trans:value
      ->
        error "Arrays have no representation" if value.type.isArray?
    Call trans:fun trans*:args
      ->
        error "Trying to call what is not a function" unless fun.isFunction?
        if args.length isnt fun.args.length
          error "Wrong number of arguments"
        else
          for arg, i in args
            error "Wrong type of an argument" unless arg.type.equals fun.args[i].type
        new Value fun.returnType

    Return trans:value
      ->
        error "Arrays cannot be returned" if value.type.isArray?
    Input trans:variable
      ->
        error "Arrays and functions cannot be input" if variable.isFunction? or variable.type.isArray?

    If trans:cond transMany transMany
      ->
        error "Condition must be a boolean" unless cond.type.equals types.boolean

    Until trans:cond transMany
      ->
        error "Condition must be a boolean" unless cond.type.equals types.boolean

    Spider trans:itemType
      ->
        new ArrayType itemType

    Type :label
      ->
        new Type label

    Logic :op trans:b1 trans?:b2
      ->
        error "Wrong type of operand, expected boolean" unless b1.type.equals types.boolean
        error "Wrong type of operand, expected boolean" if b2? and not b2.type.equals types.boolean
        new Value types.boolean

    Compare :op trans:e1 trans:e2
      ->
        console.log e1
        console.log e2
        error "Wrong type of operand, expected number or a letter" unless (e1.type.equalsAny types.number, types.letter)
        #error "Wrong type of operand, expected number or a letter" unless (e2.type.equalsAny types.number, types.letter)
        #error "Wrong type of operand, operands must have the same type" unless (e1.type.equals e2.type)
        new Value types.boolean

    Arithmetic :op trans:e1 trans?:e2
      ->
        error "Wrong type of operand, expected number" unless e1.type.equals types.number
        error "Wrong type of operand, expected number" if e2? and not e2.type.equals types.number
        new Value types.number

    Dereference :name
      ->
        @lookup name

    Element trans:array trans:index
      ->
        if not array.type.isArray?
          error "Trying to access element of nonarray"
          type = types.error
        else
          type = array.type.itemType
        error "Array's index must be a number" unless index.type.equals types.number
        new Value type

    Number :n
      ->
        new Value types.number

    Letter :ch
      ->
        new Value types.number

    Sentence :string
      ->
        new Value types.sentence

    createScope
      ->
        outerScope = @currentScope
        @currentScope = new Scope outerScope, {}

    exitScope
      ->
        @currentScope = @currentScope.outer


  MAliceSemantics::declare = (identifier) ->
    alreadyDeclared = @currentScope.declaredInCurrent identifier
    if alreadyDeclared
      console.error "#{identifier.name} already declared in current scope"
    else
      @currentScope.add identifier
    console.log "#{identifier.name} declared"
    identifier

  MAliceSemantics::lookup = (name) ->
    @lookupIn name, @currentScope

  MAliceSemantics::lookupIn = (name, scope) ->
    reference = scope.get name
    if reference?
      return reference
    else
      console.error "#{name} undeclared"
      return new Reference name, types.error

  class Node
    constructor: (@type) ->

  class Scope
    constructor: (@outer, @declarations) ->

    toString: ->
      "Scope#{dump.parse @declarations}"

    add: (identifier) ->
      @declarations[identifier.name] = identifier

    addAll: (identifiers) ->
      @add identifier for identifier in identifiers

    declaredInCurrent: (identifier) ->
      @declarations[identifier.name]?

    get: (name) ->
      @declarations[name] or @outer?.get name

  class Identifier # Could also hold a reference to the ASTnode that declares Identifier

  class Type extends Identifier
    constructor: (@label) ->
    equals: (t) ->
      @label is t.label or t.isError
    equalsAny: (ts...) ->
      ts.some (t) ->
        @equals t
      , this


  class ErrorType extends Identifier
    isError: yes
    equals: (t) ->
      yes

  class Value extends Identifier
    constructor: (@type) ->

  class Reference extends Identifier
    constructor: (@name, @type) ->

  class FunctionIdentifier extends Identifier
    constructor: (@name, @returnType, @args, @scope) ->
    isFunction: yes

  class ArrayType extends Type
    constructor: (@itemType) ->
    isArray: yes
    equals: (t) ->
      t.isArray and @itemType.equals t.itemType

  types =
    number: new Type "number"
    letter: new Type "letter"
    sentence: new Type "sentence"
    boolean: new Type "boolean"
    error: new ErrorType

  MAliceSemantics.match ast, "trans", undefined, (m, i) -> error "ERROR in #{m}, #{i}"