dump = require './jsDump'
clc = require('cli-color');

module.exports = (OMeta, OMLib) -> analyze: (ast) ->

  error = (message) ->
    console.error "#{clc.redBright "Semantic error:"} \n" + ((message.split '\n').map (line) -> "  #{line}").join('\n')

  typeError = (name, expected, actual) ->
    error "Type mismatch for #{name}, expected '#{expected.toString()}', got '#{actual.toString()}'"

  log = (xs...) ->
    console.log dump.parse x for x in xs

  ometa MAliceSemantics
    trans = <[:t apply(t):ans]>:node -> ans?.node = node; ans

    Program createScope:scope trans:declarations
      ->
        hatta = scope.get 'hatta'
        if not hatta? 
          error "The main function named 'hatta' was not declared."
        else if not hatta.type.equals types.function
          error "The main function named 'hatta' was not declared. Instead, 'hatta' was declared as '#{hatta.type.toString()}'"
        else if not hatta.returnType.equals types.void
          error """The main function named 'hatta' cannot return a value.
                   Instead, 'hatta' was declared to return '#{hatta.returnType.toString()}'""", hatta.at


    Function :name trans:returnType trans:args 
             createScope:scope {scope.addAll args; scope.returns returnType} trans:body exitScope
      ->
        @declare new FunctionIdentifier name, returnType, args

    Arguments trans*

    Argument :name trans:type
      ->
        new Reference name, type

    Block createScope:scope trans:declarations trans:statements exitScope

    Declarations trans*

    Variable :name trans:type trans:value
      ->
        @declare new Reference name, type

    Array :name trans:size trans:itemType
      ->
        typeError "array size", types.number, size.type unless size.type.equals types.number
        @declare new Reference name, new ArrayType itemType

    Skip
      ->
    Assignment trans:assignable trans:value
      ->
        unless assignable.type.equals value.type
          error "Type mismatch in assignment, reference is a '#{assignable.type.toString()}', value is a '#{value.type.toString()}'"

    Decrement trans:variable
      ->
        typeError "decrement", types.number, variable.type unless variable.type.equals types.number

    Increment trans:variable
      ->
        typeError "increment", types.number, variable.type unless variable.type.equals types.number

    Output trans:value
      ->
        error "#{value.type.toString()} has no printable representation" unless value.type.isDynamic

    Call trans:fun trans*:args
      ->
        typeError "function call", types.function, fun.type unless fun.isFunction?
        if args.length isnt fun.args.length
          error "Function #{fun.name} expects #{fun.args.length} arguments, got #{args.length} arguments"
        else
          for arg, i in args
            typeError "argument #{i+1}", fun.args[i].type, arg.type unless arg.type.equals fun.args[i].type
        new Value fun.returnType

    Return trans:value
      ->
        currentReturnType = @currentScope.returns()
        if currentReturnType.equals types.void
          error "Return statement inside void function" 
        else if not value.type.equals currentReturnType
          typeError "return statement", currentReturnType, value.type

    Input trans:variable
      ->
        typeError "input statement", dynamicTypes.join(' or '), variable.type unless variable.type.isDynamic

    If trans:cond trans trans
      ->
        typeError "condition", types.boolean, cond.type unless cond.type.equals types.boolean

    Until trans:cond trans
      ->
        typeError "loop condition", types.boolean, cond.type unless cond.type.equals types.boolean

    Statements trans*

    Spider trans:itemType
      ->
        new ArrayType itemType

    Type :label
      ->
        new Type label

    Logic :op trans:b1 trans?:b2
      ->
        for operand in [b1, b2] when operand?
          typeError "operand of #{op}", types.boolean, b1.type unless b1.type.equals types.boolean
        new Value types.boolean

    Compare :op trans:e1 trans:e2
      ->
        comparableTypes = [types.number, types.letter]
        comparableTypesNames = comparableTypes.join " or "
        for operand in [e1, e2]
          typeError "operand of '#{op}'", comparableTypesNames, operand.type unless operand.type.equalsAny comparableTypes
        error "Type mismatch for '#{op}', operands must match, got '#{e1.type}' and '#{e2.type}'" unless e1.type.equals e2.type
        new Value types.boolean

    Arithmetic :op trans:e1 trans?:e2
      ->
        for operand in [e1, e2] when operand?
          typeError "operand of #{op}", types.number, operand.type unless e1.type.equals types.number
        new Value types.number

    Dereference :name
      ->
        @lookup name

    Element trans:array trans:index
      ->
        if not array.type.isArray?
          typeError "array access", new ArrayType "<?>", array.type
          type = types.error
        else
          type = array.type.itemType
        typeError "array index", types.number, index.type unless index.type.equals types.number
        new Value type

    Number :n
      ->
        new Value types.number

    Letter :ch
      ->
        new Value types.letter

    Sentence :string
      ->
        new Value types.sentence

    createScope
      ->
        outerScope = @currentScope
        @currentScope = new Scope outerScope, {}

    exitScope
      ->
        @currentScope = @currentScope.outer


  MAliceSemantics::declare = (identifier) ->
    alreadyDeclared = @currentScope.declaredInCurrent identifier
    if alreadyDeclared
      error "#{identifier.name} already declared in current scope"
    else
      @currentScope.add identifier
    #log "#{identifier.name} declared"
    identifier

  MAliceSemantics::lookup = (name) ->
    @lookupIn name, @currentScope

  MAliceSemantics::lookupIn = (name, scope) ->
    reference = scope.get name
    if reference?
      return reference
    else
      console.error "#{name} undeclared"
      return new Reference name, types.error

  class Scope
    constructor: (@outer, @declarations) ->

    toString: ->
      "Scope#{dump.parse @declarations};#{@returnType}"

    add: (identifier) ->
      @declarations[identifier.name] = identifier

    addAll: (identifiers) ->
      @add identifier for identifier in identifiers

    returns: (type) ->
      if type?
        @returnType = type
      else
        @returnType ? @outer.returns()

    declaredInCurrent: (identifier) ->
      @declarations[identifier.name]?

    get: (name) ->
      @declarations[name] or @outer?.get name

  class Identifier # Could also hold a reference to the ASTnode that declares Identifier

  class Type extends Identifier
    constructor: (@label) ->
    equals: (t) ->
      @label is t.label or t.isError
    equalsAny: (ts) ->
      ts.some (t) ->
        @equals t
      , this
    toString: ->
      @label
    isDynamic: true

  class FunctionType extends Type
    label: "function"
    isDynamic: false 

  class ArrayType extends Type
    constructor: (@itemType) ->
    isArray: yes
    isDynamic: false
    equals: (t) ->
      t.isArray and @itemType.equals t.itemType
    toString: ->
      "spider #{@itemType}"

  class ErrorType extends Identifier
    isError: yes
    equals: (t) ->
      yes
    toString: ->
      "error"

  class Value extends Identifier
    constructor: (@type) ->

  class Reference extends Identifier
    constructor: (@name, @type) ->

  class FunctionIdentifier extends Identifier
    constructor: (@name, @returnType, @args, @scope) ->
    isFunction: yes
    isDynamic: false
    type: new FunctionType

  types =
    number: new Type "number"
    letter: new Type "letter"
    sentence: new Type "sentence"
    boolean: new Type "boolean"
    function: new FunctionType
    void: new Type "void"
    error: new ErrorType

  dynamicTypes = [types.number, types.letter, types.sentence]

  MAliceSemantics.match ast, "trans", undefined, (m, i) -> error "ERROR in #{m}, #{i}"