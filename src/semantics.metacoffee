#
# semantics.metacoffee
#
#   Semantic analysis, type and error checking
#

errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'

module.exports = (OMeta, OMLib) -> analyze: (source, ast) ->

  #
  # Used for highlighting the location of an error, returns a position or undefined
  #
  #   where: Identifier with a position or position in the form [begin, end] or undefined
  #
  locate = (where) ->
    where?.position?() ? where

  #
  # Print a nicely formatted error using the error handler
  #
  #   message:           The error message to print
  #   where [optional]:  Location as per `locate`
  #   detail [optional]: Location as per `locate`
  #
  printError = (label, message, where, detail) ->
    console.error errorHandler.format
      label: label
      input: source
      position: locate where
      message: message
      detail: locate detail

  error = (message, where, detail) ->
    printError "Semantic error", message, where, detail

  warning = (message, where, detail) ->
    printError "Semantic warning", message, where, detail

  #
  # Print a type error using the error handler
  #
  #   name:          Context in which the error has arisen
  #   expected:      Identifier object(s) (e.g. a `types` constant) representing the expected type
  #   actual:        Identifier object representing the actual type encountered
  #   expectedWhere [optional]: Location as per `locate` of the declaration of the expected type
  #
  typeError = (name, expected, actual, expectedWhere) ->
    expectedLabels = ("'#{type}'" for type in alwaysArray expected).join ' or '
    if not expectedWhere?
      error "Type clash for #{name}, expected #{expectedLabels}, got '#{actual.type()}'", actual
    else
      error "Type clash for #{name}, got '#{actual.type()}', expected #{expectedLabels} as declared", actual, expectedWhere

  #
  # Check for a type error by comparing `actual.type()` to `expected` types
  #
  checkForTypeError = (name, expected, actual, expectedWhere) ->
    unless actual.type().equalsAny alwaysArray expected
      typeError name, expected, actual, expectedWhere
      return true
    return false

  alwaysArray = (something) ->
    if Array.isArray something[0] then something else [something]

  #
  # Given a list positions, return the range that spans them all
  #
  allSpan = (values) ->
    [start, _] = values[0].position()
    [_, end] = values[values.length - 1].position()
    [start, end]

  #
  # Rules for semantic actions
  #
  #   The rules defined here perform a match on the abstract syntax tree
  #   generated by the parser (in parser.metacoffee).
  #
  #   There is a rule for every type of node in the AST.
  #
  #   Nodes in the AST are expected to be of the form
  #
  #     ['RuleName', position, ...]
  #     where
  #       position = [begin, end]
  #
  #   The rules are defined with the so-called "ML-style syntax", which differs
  #   slightly from the parser syntax by omitting the equals sign in rule definitions, so
  #
  #     RuleName terminals and non-terminals -> semantic action
  #
  #   is equivalent to
  #
  #     RuleName = terminals and non-terminals -> semantic action
  #
  #   Colons bind the value returned by the matched rule to a variable, which
  #   can then be referred to in the semantic action function.
  #
  #   A bound variable not preceded by a rule name will match anything.
  #
  #   A reference to the current scope is stored in the field `@currentScope`.
  #   A scope is set up by matching the `createScope` rule before matching the
  #   rest of the rule. Similarly, the scope is reset in the `exitScope` rule
  #   (see the `Block` rule for an example of scope creation).
  #
  #   The tree traversal is carried out by the `trans` rule. it matches the
  #   first element in an array and uses it as the rule name of the rule
  #   to be applied on the rest of the array.
  #   It also captures the original array (in this case the AST node) and
  #   stores it in the result's `node` field.
  #
  ometa MAliceSemantics
    trans = [:t apply(t):ans] -> ans

    Program :pos createScope:scope trans:declarations
      ->  hatta = scope.get 'hatta'
          if not hatta?
            error "The main function named 'hatta' was not declared."
          else if not hatta.type().equals types.function
            error "The main function named 'hatta' was not declared. Instead, 'hatta' was declared as '#{hatta.type()}'", hatta
          else if not hatta.returnType().equals types.void
            error "The main function named 'hatta' cannot return a value. " +
                  "Instead, 'hatta' was declared to return '#{hatta.returnType()}'", hatta.returnType()
          new Node 'Program', pos, declarations

    Function :pos :name trans:returnType trans:args  {
        @prepareScope = [args, returnType]
        @declare new FunctionNode 'Function', pos, types.function, name, returnType, args
      }:fun trans:body
      -> warning "There are paths in '#{name}' that don't return a value" unless body.doesReturn() or returnType.equals types.void
         concat fun, [body]

    Arguments :pos trans*:args

    Argument :pos :name trans:type
      ->  new Reference 'Argument', pos, type, name

    Block :pos createScope:scope trans:declarations trans:statements exitScope
      ->  new Executes 'Block', pos, (statements.doesReturn()), declarations, statements

    Declarations :pos trans*:ds
      ->  new Node 'Declarations', pos, ds

    Variable :pos :name trans:type trans:value
      ->  @declare new Reference 'Variable', pos, type, name, value

    Array :pos :name trans:size trans:itemType
      ->  checkForTypeError "specifying array size", types.number, size
          @declare new Reference 'Array', pos, new ArrayType(pos, itemType), name, size

    Skip
      -> new Executes 'Skip', undefined, false

    Assignment :pos trans:assignable trans:value
      ->  if not assignable.type().isDynamic
            error "Variable of type '#{assignable.type()}' cannot be assigned to", assignable
          else if not assignable.type().equals value.type()
            error "Type clash in assignment, variable is a '#{assignable.type()}', value is a '#{value.type()}'", value
          new Executes 'Assignment', pos, false, assignable, value

    Decrement :pos trans:variable
      ->  checkForTypeError "decrement", types.number, variable
          new Executes  'Decrement', pos, false, variable

    Increment :pos trans:variable
      ->  checkForTypeError "increment", types.number, variable
          new Executes 'Increment', pos, false, variable

    Output :pos trans:value
      ->  error "'#{value.type()}' has no printable representation", value unless value.type().isDynamic
          new Executes 'Output', pos, false, value

    Call :pos :isStatement trans:fun trans*:args
      ->  validFunction = not checkForTypeError "function call", types.function, fun
          if validFunction
            if isStatement and not fun.returnType().equals types.void
              error "'#{fun.name()}' is not a procedure, as declared", fun, fun.declaredAt()
            if args.length isnt fun.args().length
              error "Call to '#{fun.name()}' has #{args.length} argument#{if args.length > 1 then 's' else ''}, " +
                    "expected #{fun.args().length} as declared", allSpan(args), allSpan(fun.args())
            else
              for arg, i in args
                checkForTypeError "argument #{i+1}", fun.args()[i].type(), arg, fun.args()[i].type()
          if isStatement
            concat new Executes('Call', pos, false, isStatement, fun), args
          else
            type = if validFunction then fun.returnType() else types.error
            concat new Value('Call', pos, type, isStatement, fun), args

    Return :pos trans:value
      ->  currentReturnType = @currentScope.returns()
          if currentReturnType.equals types.void
            error "Return statement inside void function"
          else
            checkForTypeError "return statement", currentReturnType, value, currentReturnType
          new Executes 'Return', pos, true, value

    Input :pos trans:variable
      ->  typeError "input statement", dynamicTypes, variable unless variable.type().isDynamic
          new Executes 'Input', pos, false, variable

    If :pos trans:cond trans:ifReturns trans:elseReturns
      ->  checkForTypeError "condition", types.boolean, cond
          new Executes 'If', pos, ifReturns.doesReturn() and elseReturns.doesReturn(), cond, ifReturns, elseReturns

    Until :pos trans:cond trans:body
      ->  checkForTypeError "loop condition", types.boolean, cond
          new Executes 'Until', pos, false, cond, body

    Statements :pos trans*:ss
      -> concat new Executes('Statements', pos, (ss.some (statement) -> statement.doesReturn())), ss

    Spider :pos trans:itemType
      ->  new ArrayType pos, itemType

    Type :pos :label
      ->  new SimpleType pos, label

    Logic :pos :op trans:b1 trans?:b2
      ->  for operand in [b1, b2] when operand?
            checkForTypeError "operand of #{op}", types.boolean, operand
          new Value 'Logic', pos, types.boolean, op, b1, b2

    Compare :pos :op trans:e1 trans:e2
      ->  for operand in [e1, e2]
            checkForTypeError "operand of '#{op}'", arithmeticTypes, operand
          unless e1.type().equals e2.type()
            error "Type clash for '#{op}', operands must match, got '#{e1.type()}' and '#{e2.type()}'", pos
          new Value 'Compare', pos, types.boolean, op, e1, e2

    Arithmetic :pos :op trans:e1 trans:e2
      ->  for operand in [e1, e2]
            if checkForTypeError "operand of '#{op}'", arithmeticTypes, operand
              errorType = types.error
          if not errorType? and not e1.type().equals e2.type()
            error "Type clash for '#{op}', operands must match, got '#{e1.type()}' and '#{e2.type()}'", pos
            errorType = types.error
          new Value 'Compare', pos, errorType ? e1.type(), op, e1, e2

    Unary :pos :op trans:e
      ->  checkForTypeError "operand of '#{op}'", types.number, e
          new Value 'Unary', pos, types.number, op, e

    Dereference :pos :name
      ->  reference = @currentScope.get name
          if reference?
            Reference.from reference, pos
          else
            error "'#{name}' has not been declared", pos
            new Reference 'Dereference', pos, types.error, name

    Element :pos trans:array trans:index
      ->  if not array.type().isArray?
            typeError "array access", new ArrayType(0, "<?>"), array
            type = types.error
          else
            type = array.type().itemType()
          checkForTypeError "array index", types.number, index
          new Value 'Element', pos, type, array, index

    Number :pos :n
      ->  new Value 'Number', pos, types.number, n

    Letter :pos :ch
      ->  new Value 'Letter', pos, types.letter, ch

    Sentence :pos :string
      ->  new Value 'Sentence', pos, types.sentence, string

    createScope {
        outerScope = @currentScope
        @currentScope = new Scope outerScope, {}
      } (&{@prepareScope?} functionScope(@prepareScope))?
      ->  @currentScope

    functionScope [[anything*:args] :returnType]
      ->  @currentScope.addAll args
          @currentScope.returns returnType
          delete @prepareScope
    exitScope
      ->  @currentScope = @currentScope.outer

  #
  # Rules are methods, but they don't have formal parameters, only matches on
  # the input stream. Therefore, we need to append `declare` to the
  # MAliceSemantics prototype.
  #
  MAliceSemantics::declare = (node) ->
    alreadyDeclared = @currentScope.declaredInCurrent node
    if alreadyDeclared?
      error "'#{node.name()}' already declared", node.position(), alreadyDeclared
    else
      @currentScope.add node
    node

  # Scope
  # -----

  class Scope
    constructor: (@outer, @declarations) ->

    add: (node) ->
      @declarations[node.name()] = node

    addAll: (nodes) ->
      @add node for node in nodes

    returns: (type) ->
      if type?
        @returnType = type
      else
        @returnType ? @outer.returns()

    declaredInCurrent: (node) ->
      @declarations[node.name()]

    get: (name) ->
      @declarations[name] or @outer?.get name

  # Nodes
  # -----

  # Node is [node, position, ...]
  class Node
    @wrap = (node, methods) ->
      for name, index of methods
        do (index) ->
          node[name] = (value) ->
            if value?
              @[index] = value
              this
            else
              @[index]
      node
    constructor: ->
      node =  Array.apply (new Array), arguments
      return Node.wrap node, position: 1

  # Executes is [node, position, returns, ...]
  class Executes extends Node
    constructor: ->
      return Node.wrap super, doesReturn: 2

  # Value is [node, position, type, ...]
  class Value extends Node
    constructor: ->
      return Node.wrap super, type: 2

  # Reference is [node, position, type, name, ...]
  class Reference extends Value
    constructor: ->
      return Node.wrap super, name: 3
    @from: (node, at) ->
      copy = new Reference
      for own i, value of node
        copy[i] = value
      copy.declaredAt = -> node.position()
      copy.position at
      copy

  # FunctionNode is [node, position, type, name, returnType, ...]
  class FunctionNode extends Reference
    constructor: ->
      return Node.wrap super, returnType: 4, args: 5

  # Types
  # -----

  # Type is [node, position, ...]
  class Type extends Node
    constructor: ->
      node = Node.wrap super, label: 2
      node.isDynamic = true
      node.equals = Type::equals
      node.equalsAny = Type::equalsAny
      return node
    equals: (t) ->
      @label() is t.label() or t.isError
    equalsAny: (ts) ->
      ts.some (t) ->
        @equals t
      , this

  # SimpleType is [node, position, label, ...]
  class SimpleType extends Type
    constructor: (values...)->
      values.unshift 'Type'
      node = Node.wrap super(values...), toString: 2
      return node

  class FunctionType extends Type
    constructor: ->
      node = super undefined, "function"
      node.isDynamic = no
      return node

  # ArrayType is [node, position, itemType, ...]
  class ArrayType extends Type
    constructor: (values...) ->
      values.unshift 'ArrayType'
      node = Node.wrap super(values...), itemType: 2
      node.isArray = yes
      node.isDynamic = no
      node.equals = ArrayType::equals
      node.toString = -> "spider #{@itemType()}"
      return node
    equals: (t) ->
      t.isArray and @itemType().equals t.itemType()

  class ErrorType extends Type
    constructor: ->
      @isError = yes
      @isDynamic = yes
    equals: (t) ->
      yes
    toString: ->
      "error"

  types =
    number: new SimpleType undefined, "number"
    letter: new SimpleType undefined, "letter"
    sentence: new SimpleType undefined, "sentence"
    boolean: new SimpleType undefined, "boolean"
    function: new FunctionType
    void: new SimpleType undefined, "void"
    error: new ErrorType

  dynamicTypes = [types.number, types.letter, types.sentence]
  arithmeticTypes = [types.number, types.letter]

  #
  # Main entry point
  # Runs the semantic analyser by traversing the given AST.
  # At this point, returns the augmented AST.
  #
  MAliceSemantics.match ast, "trans", undefined, (m, i) -> console.error "ERROR while traversing AST in semantic analyzer"
