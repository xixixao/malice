dump = require './jsDump'
clc = require('cli-color');
errorHandler = require('./errorprinter');

module.exports = (OMeta, OMLib) -> analyze: (source, ast) ->

  error = (message, position) ->
    console.error errorHandler.format label: "Semantic error", input: source, position: position, message: message

  typeError = (name, expected, actual) ->
    error "Type mismatch for #{name}, expected '#{expected}', got '#{actual.type}'", actual.position()

  log = (xs...) ->
    console.log dump.parse x for x in xs

  ometa MAliceSemantics
    trans = <[:t apply(t):ans]>:node -> ans?.node = node[0]; ans

    Program :at createScope:scope trans:declarations
      ->  hatta = scope.get 'hatta'
          if not hatta?
            error "The main function named 'hatta' was not declared."
          else if not hatta.type.equals types.function
            error "The main function named 'hatta' was not declared. Instead, 'hatta' was declared as '#{hatta.type}'"
          else if not hatta.returnType.equals types.void
            error """The main function named 'hatta' cannot return a value.
                     Instead, 'hatta' was declared to return '#{hatta.returnType}'""", hatta.returnType.position()

    Function :at :name trans:returnType trans:args  {
        @declare new FunctionIdentifier name, returnType, args
        scope = @createScope()
        scope.addAll args
        scope.returns returnType
      } trans:body exitScope

    Arguments :at trans*

    Argument :at :name trans:type
      ->  new Reference name, type

    Block :at createScope:scope trans:declarations trans:statements exitScope

    Declarations :at trans*

    Variable :at :name trans:type trans:value
      ->  @declare new Reference name, type

    Array :at :name trans:size trans:itemType
      ->  typeError "array size", types.number, size unless size.type.equals types.number
          @declare new Reference name, new ArrayType itemType

    Skip
      ->
    Assignment :at trans:assignable trans:value
      ->  unless assignable.type.equals value.type
            error "Type mismatch in assignment, reference is a '#{assignable.type}', value is a '#{value.type}'"

    Decrement :at trans:variable
      ->  typeError "decrement", types.number, variable unless variable.type.equals types.number

    Increment :at trans:variable
      ->  typeError "increment", types.number, variable unless variable.type.equals types.number

    Output :at trans:value
      ->  error "#{value.type} has no printable representation" unless value.type.isDynamic

    Call :at trans:fun trans*:args
      ->  typeError "function call", types.function, fun unless fun.type.equals types.function
          if args.length isnt fun.args.length
            error "Function #{fun.name} expects #{fun.args.length} arguments, got #{args.length} arguments"
          else
            for arg, i in args
              typeError "argument #{i+1}", fun.args[i].type, arg unless arg.type.equals fun.args[i].type
          new Value fun.returnType

    Return :at trans:value
      ->  currentReturnType = @currentScope.returns()
          if currentReturnType.equals types.void
            error "Return statement inside void function"
          else if not value.type.equals currentReturnType
            typeError "return statement", currentReturnType, value

    Input :at trans:variable
      ->  typeError "input statement", dynamicTypes.join(' or '), variable unless variable.type.isDynamic

    If :at trans:cond trans trans
      ->  typeError "condition", types.boolean, cond unless cond.type.equals types.boolean

    Until :at trans:cond trans
      ->  typeError "loop condition", types.boolean, cond unless cond.type.equals types.boolean

    Statements :at trans*

    Spider :at trans:itemType
      ->  new ArrayType itemType

    Type :at :label
      ->  new Type label

    Logic :at :op trans:b1 trans?:b2
      ->  for operand in [b1, b2] when operand?
            typeError "operand of #{op}", types.boolean, b1 unless b1.type.equals types.boolean
          new Value types.boolean

    Compare :at :op trans:e1 trans:e2
      ->  comparableTypes = [types.number, types.letter]
          comparableTypesNames = comparableTypes.join " or "
          for operand in [e1, e2]
            typeError "operand of '#{op}'", comparableTypesNames, operand unless operand.type.equalsAny comparableTypes
          error "Type mismatch for '#{op}', operands must match, got '#{e1.type}' and '#{e2.type}'" unless e1.type.equals e2.type
          new Value types.boolean

    Arithmetic :at :op trans:e1 trans?:e2
      ->  for operand in [e1, e2] when operand?
            typeError "operand of #{op}", types.number, operand unless e1.type.equals types.number
          new Value types.number

    Dereference :at :name
      ->  @lookup name

    Element :at trans:array trans:index
      ->  if not array.type.isArray?
            typeError "array access", new ArrayType "<?>", array
            type = types.error
          else
            type = array.type.itemType
          typeError "array index", types.number, index unless index.type.equals types.number
          new Value type

    Number :at :n
      ->  new Value types.number

    Letter :at :ch
      ->  new Value types.letter

    Sentence :at :string
      ->  new Value types.sentence

    createScope
      ->  outerScope = @currentScope
          @currentScope = new Scope outerScope, {}

    exitScope
      ->  @currentScope = @currentScope.outer


  MAliceSemantics::declare = (identifier) ->
    alreadyDeclared = @currentScope.declaredInCurrent identifier
    if alreadyDeclared
      error "#{identifier.name} already declared in current scope"
    else
      @currentScope.add identifier
    #log "#{identifier.name} declared"
    identifier

  MAliceSemantics::lookup = (name) ->
    @lookupIn name, @currentScope

  MAliceSemantics::lookupIn = (name, scope) ->
    reference = scope.get name
    if reference?
      return reference
    else
      error "'#{name}' undeclared"
      return new Reference name, types.error

  class Scope
    constructor: (@outer, @declarations) ->

    toString: ->
      "Scope#{dump.parse @declarations};#{@returnType}"

    add: (identifier) ->
      @declarations[identifier.name] = identifier

    addAll: (identifiers) ->
      @add identifier for identifier in identifiers

    returns: (type) ->
      if type?
        @returnType = type
      else
        @returnType ? @outer.returns()

    declaredInCurrent: (identifier) ->
      @declarations[identifier.name]?

    get: (name) ->
      @declarations[name] or @outer?.get name

  class Identifier # Also holds a reference to the ASTnode that declares Identifier
    position: ->
      [nodeName, at] = @node
      at

  class Type extends Identifier
    constructor: (@label) ->
    equals: (t) ->
      @label is t.label or t.isError
    equalsAny: (ts) ->
      ts.some (t) ->
        @equals t
      , this
    toString: ->
      @label
    isDynamic: true

  class FunctionType extends Type
    label: "function"
    isDynamic: false

  class ArrayType extends Type
    constructor: (@itemType) ->
    isArray: yes
    isDynamic: false
    equals: (t) ->
      t.isArray and @itemType.equals t.itemType
    toString: ->
      "spider #{@itemType}"

  class ErrorType extends Identifier
    isError: yes
    equals: (t) ->
      yes
    toString: ->
      "error"

  class Value extends Identifier
    constructor: (@type) ->

  class Reference extends Identifier
    constructor: (@name, @type) ->

  class FunctionIdentifier extends Identifier
    constructor: (@name, @returnType, @args) ->
    type: new FunctionType

  types =
    number: new Type "number"
    letter: new Type "letter"
    sentence: new Type "sentence"
    boolean: new Type "boolean"
    function: new FunctionType
    void: new Type "void"
    error: new ErrorType

  dynamicTypes = [types.number, types.letter, types.sentence]

  MAliceSemantics.match ast, "trans", undefined, (m, i) -> console.error "ERROR while traversing ast in semantic analyzer in #{m}, #{i}"