#
# semantics.metacoffee
#
#   Semantic analysis, type and error checking
#

errorHandler = require './errorprinter'

module.exports = (OMeta, OMLib) -> analyze: (source, ast) ->

  #
  # Used for highlighting the location of an error, returns a position or undefined
  #
  #   where: Identifier with a position or position in the form [begin, end] or undefined
  #
  locate = (where) ->
    where?.position?() ? where

  #
  # Print a nicely formatted error using the error handler
  #
  #   message:           The error message to print
  #   where [optional]:  Location as per `locate`
  #   detail [optional]: Location as per `locate`
  #
  error = (message, where, detail) ->
    console.error errorHandler.format
      label: "Semantic error"
      input: source
      position: locate where
      message: message
      detail: locate detail

  #
  # Print a type error using the error handler
  #
  #   name:          Context in which the error has arisen
  #   expected:      Identifier object(s) (e.g. a `types` constant) representing the expected type
  #   actual:        Identifier object representing the actual type encountered
  #   expectedWhere [optional]: Location as per `locate` of the declaration of the expected type
  #
  typeError = (name, expected, actual, expectedWhere) ->
    expectedLabels = ("'#{type}'" for type in alwaysArray expected).join ' or '
    if not expectedWhere?
      error "Type clash for #{name}, expected #{expectedLabels}, got '#{actual.type}'", actual
    else
      error "Type clash for #{name}, got '#{actual.type}', expected #{expectedLabels} as declared", actual, expectedWhere

  # 
  # Check for a type error by comparing `actual.type` to `expected` types
  #
  checkForTypeError = (name, expected, actual, expectedWhere) ->
    unless actual.type.equalsAny alwaysArray expected
      typeError name, expected, actual, expectedWhere
      return true
    return false

  alwaysArray = (something) ->
    if Array.isArray something then something else [something]

  #
  # Given a list positions, return the range that spans them all
  #
  allSpan = (values) ->
    [start, _] = values[0].position()
    [_, end] = values[values.length - 1].position()
    [start, end]

  #
  # Rules for semantic actions
  #
  #   The rules defined here perform a match on the abstract syntax tree
  #   generated by the parser (in parser.metacoffee).
  #
  #   There is a rule for every type of node in the AST.
  #
  #   Nodes in the AST are expected to be of the form
  #
  #     ['RuleName', position, ...]
  #     where
  #       position = [begin, end]
  #
  #   The rules are defined with the so-called "ML-style syntax", which differs
  #   slightly from the parser syntax by omitting the equals sign in rule definitions, so
  #
  #     RuleName terminals and non-terminals -> semantic action
  #
  #   is equivalent to
  #
  #     RuleName = terminals and non-terminals -> semantic action
  #
  #   Colons bind the value returned by the matched rule to a variable, which
  #   can then be referred to in the semantic action function.
  #
  #   A bound variable not preceded by a rule name will match anything.
  #
  #   A reference to the current scope is stored in the field `@currentScope`.
  #   A scope is set up by matching the `createScope` rule before matching the
  #   rest of the rule. Similarly, the scope is reset in the `exitScope` rule
  #   (see the `Block` rule for an example of scope creation).
  #
  #   The tree traversal is carried out by the `trans` rule. it matches the
  #   first element in an array and uses it as the rule name of the rule
  #   to be applied on the rest of the array.
  #   It also captures the original array (in this case the AST node) and 
  #   stores it in the result's `node` field.
  #
  ometa MAliceSemantics
    trans = <[:t apply(t):ans]>:node -> ans?.node = node[0]; ans

    Program :pos createScope:scope trans:declarations
      ->  hatta = scope.get 'hatta'
          if not hatta?
            error "The main function named 'hatta' was not declared."
          else if not hatta.type.equals types.function
            error "The main function named 'hatta' was not declared. Instead, 'hatta' was declared as '#{hatta.type}'", hatta
          else if not hatta.returnType.equals types.void
            error "The main function named 'hatta' cannot return a value. " +
                  "Instead, 'hatta' was declared to return '#{hatta.returnType}'", hatta.returnType

    Function :pos :name trans:returnType trans:args  {
        identifier = @declare (new FunctionIdentifier name, returnType, args), pos
        scope = @createScope()
        scope.addAll args
        scope.returns returnType
        return identifier
      }:i trans:body exitScope
      -> i

    Arguments :pos trans*

    Argument :pos :name trans:type
      ->  new Reference name, type

    Block :pos createScope:scope trans:declarations trans:statements exitScope

    Declarations :pos trans*

    Variable :pos :name trans:type trans:value
      ->  @declare (new Reference name, type), pos

    Array :pos :name trans:size trans:itemType
      ->  checkForTypeError "specifying array size", types.number, size
          @declare (new Reference name, new ArrayType itemType), pos

    Skip
      ->

    Assignment :pos trans:assignable trans:value
      ->  if not assignable.type.isDynamic
            error "Variable of type '#{assignable.type}' cannot be assigned to", assignable
          else if not assignable.type.equals value.type
            error "Type clash in assignment, variable is a '#{assignable.type}', value is a '#{value.type}'", value

    Decrement :pos trans:variable
      ->  checkForTypeError "decrement", types.number, variable

    Increment :pos trans:variable
      ->  checkForTypeError "increment", types.number, variable

    Output :pos trans:value
      ->  error "'#{value.type}' has no printable representation", value unless value.type.isDynamic

    Call :pos trans:fun trans*:args
      ->  checkForTypeError "function call", types.function, fun
          if args.length isnt fun.args.length
            error "Call to '#{fun.name}' has #{args.length} argument#{if args.length > 1 then 's' else ''}, " +
                  "expected #{fun.args.length} as declared", allSpan(args), allSpan(fun.args)
          else
            for arg, i in args
              checkForTypeError "argument #{i+1}", fun.args[i].type, arg, fun.args[i].type
          new Value fun.returnType

    Return :pos trans:value
      ->  currentReturnType = @currentScope.returns()
          if currentReturnType.equals types.void
            error "Return statement inside void function"
          else 
            checkForTypeError "return statement", currentReturnType, value, currentReturnType

    Input :pos trans:variable
      ->  typeError "input statement", dynamicTypes, variable unless variable.type.isDynamic

    If :pos trans:cond trans trans
      ->  checkForTypeError "condition", types.boolean, cond

    Until :pos trans:cond trans
      ->  checkForTypeError "loop condition", types.boolean, cond

    Statements :pos trans*

    Spider :pos trans:itemType
      ->  new ArrayType itemType

    Type :pos :label
      ->  new Type label

    Logic :pos :op trans:b1 trans?:b2
      ->  for operand in [b1, b2] when operand?
            checkForTypeError "operand of #{op}", types.boolean, operand
          new Value types.boolean

    Compare :pos :op trans:e1 trans:e2
      ->  for operand in [e1, e2]
            checkForTypeError "operand of '#{op}'", arithmeticTypes, operand
          unless e1.type.equals e2.type
            error "Type clash for '#{op}', operands must match, got '#{e1.type}' and '#{e2.type}'", pos
          new Value types.boolean

    Arithmetic :pos :op trans:e1 trans:e2
      ->  for operand in [e1, e2]
            if checkForTypeError "operand of '#{op}'", arithmeticTypes, operand
              type = types.error
          if not e1.type.equals e2.type
            error "Type clash for '#{op}', operands must match, got '#{e1.type}' and '#{e2.type}'", pos
            type = types.error
          new Value type ? e1.type

    Unary :pos :op trans:e
      ->  checkForTypeError "operand of '#{op}'", types.number, e
          new Value types.number

    Dereference :pos :name
      ->  reference = @currentScope.get name
          if reference?
            Reference.from reference
          else
            error "'#{name}' is undeclared", pos
            new Reference name, types.error

    Element :pos trans:array trans:index
      ->  if not array.type.isArray?
            typeError "array access", new ArrayType "<?>", array
            type = types.error
          else
            type = array.type.itemType
          checkForTypeError "array index", types.number, index
          new Value type

    Number :pos :n
      ->  new Value types.number

    Letter :pos :ch
      ->  new Value types.letter

    Sentence :pos :string
      ->  new Value types.sentence

    createScope
      ->  outerScope = @currentScope
          @currentScope = new Scope outerScope, {}

    exitScope
      ->  @currentScope = @currentScope.outer

  #
  # Rules are methods, but they don't have formal parameters, only matches on
  # the input stream. Therefore, we need to append `declare` to the 
  # MAliceSemantics prototype.
  #
  MAliceSemantics::declare = (identifier, pos) ->
    alreadyDeclared = @currentScope.declaredInCurrent identifier
    if alreadyDeclared?
      error "'#{identifier.name}' already declared", pos, alreadyDeclared
    else
      @currentScope.add identifier
    identifier


  class Scope
    constructor: (@outer, @declarations) ->

    add: (identifier) ->
      @declarations[identifier.name] = identifier

    addAll: (identifiers) ->
      @add identifier for identifier in identifiers

    returns: (type) ->
      if type?
        @returnType = type
      else
        @returnType ? @outer.returns()

    declaredInCurrent: (identifier) ->
      @declarations[identifier.name]

    get: (name) ->
      @declarations[name] or @outer?.get name

  # Also holds a reference to the ASTnode that declares Identifier
  class Identifier 
    position: ->
      if @node
        [nodeName, pos] = @node
        pos
      else
        null

  class Type extends Identifier
    constructor: (@label) ->
      @isDynamic = true
    equals: (t) ->
      @label is t.label or t.isError
    equalsAny: (ts) ->
      ts.some (t) ->
        @equals t
      , this
    toString: ->
      @label

  class FunctionType extends Type
    constructor: ->
      super "function"
      @isDynamic = no

  class ArrayType extends Type
    constructor: (@itemType) ->
      @isArray = yes
      @isDynamic = no
    equals: (t) ->
      t.isArray and @itemType.equals t.itemType
    toString: ->
      "spider #{@itemType}"

  class ErrorType extends Type
    constructor: ->
      @isError = yes
      @isDynamic = yes
    equals: (t) ->
      yes
    toString: ->
      "error"

  class Value extends Identifier
    constructor: (@type) ->

  class Reference extends Identifier
    constructor: (@name, @type) ->
    @from: (identifier) ->
      copy = new Reference
      for own key, value of identifier
        copy[key] = value
      copy.declaredAt = identifier.position()
      copy

  class FunctionIdentifier extends Identifier
    constructor: (@name, @returnType, @args) ->
      @type = new FunctionType

  types =
    number: new Type "number"
    letter: new Type "letter"
    sentence: new Type "sentence"
    boolean: new Type "boolean"
    function: new FunctionType
    void: new Type "void"
    error: new ErrorType

  dynamicTypes = [types.number, types.letter, types.sentence]
  arithmeticTypes = [types.number, types.letter]

  #
  # Main entry point
  # Runs the semantic analyser by traversing the given AST.
  # At this point, it doesn't return a meaningful structure, it only serves
  # as an analyser.
  #
  MAliceSemantics.match ast, "trans", undefined, (m, i) -> console.error "ERROR while traversing AST in semantic analyzer"
