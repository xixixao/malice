errorHandler = require './errorprinter'
{concat} = require './metaCoffeeUtils'
{types} = require './nodes'

module.exports = (OMeta, OMLib) -> generateCode: (ast) ->

  registers = [
    "rax"
    "rbx"
    "rcx"
    "rdx"
    "r8"
    "r9"
    "r10"
    "r11"
    "r12"
    "r13"
    "r14"
    "r15"
  ]

  ometa MAliceCodeGeneration

    trans = [:t apply(t):ans] -> ans
    list = trans*:result end -> @finalOutput result

    Label :name
      -> ["#{name}:"]
    Begin
      -> ['\tpush rbp',
          '\tmov rbp, rsp']
    End :name
      -> ['\tleave',
          '\tret']
    Variable :name :type
      -> [""]
    Array :name :type :size
      -> [""]
    IfFalse :condition :jumpto
      -> ["\tcmp #{condition}, 0",
          "je #{jumpto}"]
    IfTrue :condition :jumpto
      -> ["\tcmp #{condition}, 0",
          "\tjne #{jumpto}"]
    Jump :to
      -> ["\tjmp #{to}"]
    Param :name
      -> ["\tpush #{@accessVariable name}"]
    ParamPtr :name
      -> [""]
    Argument :name :type
      -> [""]
    ArgumentPtr :name :type
      -> [""]
    ArrayAccess :into :array :i
      -> ["\tmov #{@accessVariable into}, [#{@accessVariable array} + #{i}]"]
    ArrayAssignment :array :i :value
      -> ["\tmov [#{@accessVariable array}+#{i}], #{@accessVariable value}"]
    Decrement :variable
      -> ["\tdec #{@accessVariable variable}"]
    Increment :variable
      -> ["\tinc #{@accessVariable variable}"]
    Call :name :argumentCount
      -> ["\tcall #{name}",
          "\tadd rsp, #{4 * argumentCount}"]
    Assignment :into :from
      -> ["\tmov #{@accessVariable into}, #{@accessVariable from}"]
    PtrAssignment :into :from
      -> ["\tmov [#{@accessVariable into}], #{@accessVariable from}"]
    ValAssignment :into :value :type
      -> if type.equals types.sentence
           @storeInData into, value
           return []
         if type.equals types.letter
           value = value.charCodeAt 0
         ["\tmov #{@accessVariable into}, #{value}"]
    CallAssignment :into :name :argumentCount
      -> ["\tcall #{name}",
          "\tadd rsp, #{4 * argumentCount}",
          "\tmov #{@accessVariable into}, eax"]
    ImmAssignment :into :operator :e1 anything?:e2
      -> [""]
    Return :result
      -> ["\tmov eax, #{@accessVariable result}",
          "\tret"]
    Output :value :type
      -> result = []
         if type.equals types.sentence
           result.push "\tmov rdi, #{@accessVariable '_stringFormat'}"
         else if type.equals types.letter
           result.push "\tmov rdi, #{@accessVariable '_charFormat'}"
         else if type.equals types.number
           result.push "\tmov rdi, #{@accessVariable '_numberFormat'}"
         result = concat result, ["\tmov rsi, #{@accessVariable value}",
                                  "\tmov eax, 0",
                                  "\tcall printf"]
    Read :into :type
      -> [""]

    initialize
      -> @registerCounter = 0
         @variables = {}
         @data = []
         @dataCount = 0
         @storeInData '_charFormat', '%c'
         @storeInData '_stringFormat', '%s'
         @storeInData '_numberFormat', '%d'

  MAliceCodeGeneration::accessVariable = (variable) ->
    unless @variables[variable]?
      @variables[variable] = registers[@registerCounter++]
    @variables[variable]

  MAliceCodeGeneration::storeInData = (name, string) ->
    @data.push ".LC#{@dataCount}:"
    @data.push """\t.string "#{string}" """
    @variables[name] = "OFFSET FLAT:.LC#{@dataCount}"
    @dataCount++

  MAliceCodeGeneration::finalOutput = (instructions) ->
    output = ['.intel_syntax noprefix']
    output.push '.section .rodata'
    output = concat output, @data
    output.push '.text'
    output.push '\t.globl main'
    output = concat output, (concat instructions...)
    output.join '\n'


    #global = MAliceCodeGeneration.matchAll ast.global, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
  MAliceCodeGeneration.matchAll ast.stack, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
