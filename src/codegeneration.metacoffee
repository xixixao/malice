errorHandler = require './errorprinter'
{concat} = require './metaCoffeeUtils'
{types} = require './nodes'

module.exports = (OMeta, OMLib) -> generateCode: (ast) ->

  registers = [
    #"rax"
    "rbx"
    "rcx"
    #"rdx"
    "r8"
    "r9"
    "r10"
    "r11"
    "r12"
    "r13"
    "r14"
    "r15"
    "rdi"
    "rsi"
  ]

  opInstructions =
    '+': 'add'
    '-': 'sub'
    '*': 'imul'
    '|': 'or'
    '^': 'xor'
    '&': 'and'

  unaryOpInstructions =
    '-': 'neg'
    '~': 'not'

  cmpOpInstructions =
    '==': 'sete'
    '!=': 'setne'
    '<=': 'setle'
    '>=': 'setge'
    '<' : 'setl'
    '>' : 'setg'

  pushAll = ->
    registers.map (register) -> "\tpush #{register}"

  popAll = ->
    (registers.map (register) -> "\tpop #{register}").reverse()

  ometa MAliceCodeGeneration

    trans = [:t apply(t):ans] -> ans
    list = trans*:result end -> @finalOutput result

    Label :name
      -> ["#{name}:"]
    Begin
      -> ['\tpush rbp',
          '\tmov rbp, rsp']
    End :name
      -> args = []
         for argument in @liftedArguments.reverse()
           args.unshift "\tmov [rbp+#{16+8*--@argumentCount}], #{@accessVariable argument}"
         @liftedArguments = []
         concat args, ['\tleave',
                       '\tret']
    Variable :name :type
      -> [""]
    Array :name :type :size
      -> [""]
    IfFalse :condition :jumpto
      -> ["\tcmp #{@accessVariable condition}, 0",
          "\tje #{jumpto}"]
    IfTrue :condition :jumpto
      -> ["\tcmp #{@accessVariable condition}, 0",
          "\tjne #{jumpto}"]
    Jump :to
      -> ["\tjmp #{to}"]
    Param :name
      -> ["\tpush #{@accessVariable name}"]
    ParamPop :name
      -> ["\tpop #{@accessVariable name}"]
    Argument :name :type
      -> if Array.isArray name
           [name] = name
           @liftedArguments.push name
         ["\tmov #{@accessVariable name}, [rbp+#{16+8*@argumentCount++}]"]
    ArrayAccess :into :array :i
      -> ["\tmov #{@accessVariable into}, [#{@accessVariable array} + #{i}]"]
    ArrayAssignment :array :i :value
      -> ["\tmov [#{@accessVariable array}+#{i}], #{@accessVariable value}"]
    Decrement :variable
      -> ["\tdec #{@accessVariable variable}"]
    Increment :variable
      -> ["\tinc #{@accessVariable variable}"]
    Call :name :argumentCount
      -> result = ["\tcall #{name}"]
         if argumentCount > 0
           result.push "\tadd rsp, #{8 * argumentCount}"
         result
    Assignment :into :from
      -> ["\tmov #{@accessVariable into}, #{@accessVariable from}"]
    PtrAssignment :into :from
      -> ["\tmov [#{@accessVariable into}], #{@accessVariable from}"]
    ValAssignment :into :value :type
      -> if type.equals types.sentence
           @storeInData into, value
           return []
         if type.equals types.letter
           value = value.charCodeAt 0
         ["\tmov #{@accessVariable into}, #{value}"]
    CallAssignment :into :name :argumentCount
      -> ["\tcall #{name}",
          "\tadd rsp, #{8 * argumentCount}",
          "\tmov #{@accessVariable into}, rax"]
    ImmAssignment :into :op :e1 anything?:e2
      -> e1 = e2 if e2?
         if op == '/'
           ["\tmov rax, #{@accessVariable into}",
            "\txor rdx, rdx",
            "\tidiv #{@accessVariable e1}",
            "\tmov #{@accessVariable into}, rax"]
         if op in ['==', '!=', '<=', '>=', '<', '>']
           ["\tcmp #{@accessVariable into}, #{@accessVariable e1}",
            "\t#{cmpOpInstructions[op]} al",
            "\tmovzx #{@accessVariable into}, al"]
         else
           if e2?
             ["\t#{opInstructions[op]} #{@accessVariable into}, #{@accessVariable e1}"]
           else
             ["\tmov #{@accessVariable into}, #{@accessVariable e1}",
              "\t#{unaryOpInstructions[op]} #{@accessVariable into}"]


    Return :result
      -> ["\tmov rax, #{@accessVariable result}"]
    Output :value :type
      -> concat @formatString('rdi', type),
                pushAll(),
                ["\tmov rsi, #{@accessVariable value}",
                 "\tmov eax, 0",
                 "\tcall printf"],
                popAll()
    Read :into :type
      -> concat pushAll(),
                @formatString('rdi', type),
                ["\tsub rsp, 8",
                 "\tmov rsi, rsp",
                 "\tmov eax, 0",
                 "\tcall scanf",
                 "\tmov #{@accessVariable into}, [rsp]"]
    initialize
      -> @registerCounter = 0
         @variables = {}
         @data = []
         @dataCount = 0
         @liftedArguments = []
         @argumentCount = 0
         @storeInData '_charFormat', '%c'
         @storeInData '_stringFormat', '%s'
         @storeInData '_numberFormat', '%d'

  MAliceCodeGeneration::accessVariable = (variable) ->
    if Array.isArray variable
      [variable] = variable
    unless @variables[variable]?
      @variables[variable] = registers[@registerCounter++]
    @variables[variable]

  MAliceCodeGeneration::storeInData = (name, string) ->
    @data.push ".LC#{@dataCount}:"
    @data.push """\t.string "#{string}" """
    @variables[name] = "OFFSET FLAT:.LC#{@dataCount}"
    @dataCount++

  MAliceCodeGeneration::formatString = (into, type) ->
    if type.equals types.sentence
      format = '_stringFormat'
    else if type.equals types.letter
      format = '_charFormat'
    else if type.equals types.number
      format = '_numberFormat'
    ["\tmov #{into}, #{@accessVariable format}"]


  MAliceCodeGeneration::finalOutput = (instructions) ->
    output = ['.intel_syntax noprefix']
    output.push '.section .rodata'
    output = concat output, @data
    output.push '.text'
    output.push '\t.globl main'
    output = concat output, (concat instructions...)
    output = output.join '\n'
    output + '\n'

    #global = MAliceCodeGeneration.matchAll ast.global, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
  MAliceCodeGeneration.matchAll ast.stack, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
