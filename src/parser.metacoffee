module.exports = (OMeta, OMLib) -> parse: (input) ->
  {ometaError} = OMLib

  join = (xs) ->
    xs.join ''

  concat = (xs...) ->
    (xs[0]?.concat xs[1..]) ? []

  ometa MAlice
    program        = function+
    function       = funDeclaration:d                                -> concat ['Function'], d
    funDeclaration = voidFunction | valueFunction
    voidFunction   = "The looking-glass" identifier:i args:as
                     voidBlock:b                                     -> ['void', i, as, b]
    valueFunction  = "The room"          identifier:i args:as
                     "contained a" identifier:returnType
                     valueBlock:b                                    -> [returnType, i, as, b]
    args           = "(" listOf('argDeclaration', ','):as ")"        -> as
    argDeclaration = type:t identifier:n                             -> [t, n]
    voidBlock      = openBlock:b "closed"                            -> b
    valueBlock     = openBlock:b finding:f 
                     <(statements finding)>*:dead "closed"           -> ['ReturnBlock', b, f, dead]
    openBlock      = "opened" declarations:ds statements:ss          -> ['Block', concat ds, ss]
    declarations   = declaration*
    declaration    = identifier:i "was a" type:t
                     (("of" expression:e) | "too")? terminator       -> ['Declaration', i, t, e]
    statements     = (statement | voidBlock)*
    statement      = (assignment | saying):s terminator              -> s
    finding        = "Alice found" expression:e terminator           -> ['Finding', e]
                   | valueBlock
    terminator     =  ("." | "," | "and" | "but" | "then")
    assignment     = identifier:i ("became" expression:e             -> ['Assignment', i, e]
                                  | "drank"                          -> ['Increment', i]
                                  | "ate"                            -> ['Decrement', i]
                                  )
    saying         = expression:e ("said Alice" | "spoke")           -> ['Saying', e]
    type           = "number"
                   | "letter"
                   | "sentence"
    expression     = bitwiseOr
    bitwiseOr      = bitwiseOr:e1 "|" bitwiseXOr:e2                  -> ['BOR', e1, e2]
                   | bitwiseXOr
    bitwiseXOr     = bitwiseXOr:e1 "^" bitwiseAnd:e2                 -> ['BXOR', e1, e2]
                   | bitwiseAnd
    bitwiseAnd     = bitwiseAnd:e1 "&" addition:e2                   -> ['BAND', e1, e2]
                   | addition
    addition       = addition:e1 "+" multiplication:e2               -> ['Plus', e1, e2]
                   | addition:e1 "-" multiplication:e2               -> ['Minus', e1, e2]
                   | multiplication
    multiplication = multiplication:e1 "*" negation:e2               -> ['Multiply', e1, e2]
                   | multiplication:e1 "/" negation:e2               -> ['Divide', e1, e2]
                   | multiplication:e1 "%" negation:e2               -> ['Modulo', e1, e2]
                   | negation
    negation       = "~" value:v                                     -> ['Negate', v]
                   | value
    value          = number | character | string | identifier
    number         = spaces digit+:ds                                -> join ds
    character      = spaces '\'' letter:c '\''                       -> c
    string         = spaces '"' (!'"' anything)*:xs '"'              -> join xs
    identifier     = spaces letter:x (letter | '_')*:xs              -> x + join xs
    token :s       = ^token(s):t (!letter(s.charAt(0)) | !letter)    -> t

  MAlice.matchAll(input, "program", undefined, ometaError)