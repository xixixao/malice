module.exports = (OMeta, OMLib) -> parse: (input) ->
  {ometaError} = OMLib

  join = (xs) ->
    xs.join ''

  concat = (xs...) ->
    (xs[0]?.concat xs[1..]...) ? []

  log = (xs...) ->
    console.log x for x in xs

  ometa MAlice
    program         = declarations:ds spaces end                      -> concat ['Program'], ds
    function        = (valueFunction | voidFunction):d                -> concat ['Function'], d
    valueFunction   = "The room"          identifier:i args:as
                      "contained a" identifier:returnType
                      block:b                                         -> concat [returnType, i, as, b]
    voidFunction    = "The looking-glass" identifier:i args:as
                      block:b                                         -> ['void', i, as, b]
    args            = "(" listOf('argDeclaration', ','):as ")"        -> as
    argDeclaration  = eType:t identifier:n                            -> [t, n]
    block           = "opened" 
                      (declarations:ds statements:ss)? "closed"       -> concat ['Block'], ds, ss ? []
    declarations    = declaration*
    declaration     = function 
                    | variable:v terminator                           -> v
    variable        = identifier:i "was a" type:t
                      (("of" expression:e) | "too")?                  -> ['Variable', i, t, e]
                    | identifier:i "had" expression:n type:t          -> ['Array', i, n, t]
    statements      = statement+
    statement       = (assignment | saying | call):s terminator       -> s
                    | "."                                             -> ['Skip']
                    | finding | question | conditional | loop 
                    | block
    terminator      =  ("." | "," | "and" | "but" | "then")
    assignment      = assignable:x ("became" expression:e             -> ['Assignment', x, e]
                                   | "drank"                          -> ['Decrement', x]
                                   | "ate"                            -> ['Inccrement', x]
                                   )
    assignable      = arrayPiece | identifier
    saying          = expression:e ("said Alice" | "spoke")           -> ['Output', e]
    call            = identifier:i "(" expressionList:es ")"          -> ['Call', i, es]
    expressionList  = listOf('expression', ',')
    finding         = "Alice found" expression:e "."                  -> ['Return', e]
    question        = "what was" assignable:x "?"                     -> ['Input', x]
    conditional     = ("perhaps" | "either") "(" boolean:cond ")" "so"
                        statements:ss 
                      orMaybe?:elif "because Alice was unsure which"  -> ['If', cond, ss, elif]
    orMaybe         = "or maybe" "(" boolean:cond ")" "so"
                        statements:ss 
                      orMaybe?:elif                                   -> ['If', cond, ss, elif]
                    | "or"
                        statements:ss                                 -> ss
    loop            = "eventually" "(" boolean:cond ")" "because"
                        statements:ss "enough times"                  -> ['Until', cond, ss]
    eType           = "spider" type:t                                 -> ['Spider', t]
                    | type
    type            = "number"
                    | "letter"
                    | "sentence"
    boolean         = or
    or              = or:b1  "||" and:b2                              -> ['Or', b1, b2]
                    | and
    and             = and:b1 "&&" negation:b2                         -> ['And', b1, b2]
                    | negation
    negation        = "!" negation:b                                  -> ['Not', b]
                    | "(" boolean:b ")"                               -> b
                    | comparison
    comparison      = (comparison | expression):e1
                      comparisonOp:op expression:e2                   -> ['Compare', op, e1, e2]
    comparisonOp    = "==" | ">=" | "<=" | "!=" | "<" | ">"
    expression      = bitwiseOr
    bitwiseOr       = bitwiseOr:e1 "|" bitwiseXOr:e2                  -> ['BOr', e1, e2]
                    | bitwiseXOr
    bitwiseXOr      = bitwiseXOr:e1 "^" bitwiseAnd:e2                 -> ['BXOr', e1, e2]
                    | bitwiseAnd
    bitwiseAnd      = bitwiseAnd:e1 "&" addition:e2                   -> ['BAnd', e1, e2]
                    | addition
    addition        = addition:e1 "+" multiplication:e2               -> ['Plus', e1, e2]
                    | addition:e1 "-" multiplication:e2               -> ['Minus', e1, e2]
                    | multiplication
    multiplication  = multiplication:e1 "*" unary:e2                  -> ['Multiply', e1, e2]
                    | multiplication:e1 "/" unary:e2                  -> ['Divide', e1, e2]
                    | multiplication:e1 "%" unary:e2                  -> ['Modulo', e1, e2]
                    | unary
    unary           = unaryOp:op unary:e                              -> ['Unary', op, e]
                    | value
    unaryOp         = "~" | "-" | "+"
    value           = number | character | string
                    | arrayPiece | call | identifier
                    | "(" expression:e ")"                            -> e
    arrayPiece      = identifier:i "'s" expression:e "piece"          -> ['Element', i, e]
    number          = spaces digit+:ds                                -> join ds
    character       = spaces '\'' letter:c '\''                       -> c
    string          = spaces '"' (!'"' anything)*:xs '"'              -> join xs
    identifier      = # !reserved
                      spaces letter:x (letter | '_' | digit)*:xs      -> x + join xs
#>    reserved        = "The" | "looking-glass" | "room" | "became" 
                    | "perhaps" | "because" | "eventually" | "so" 
                    | "enough" | "times" | "Alice" | "said" | "spoke"
                    | "found" | "opened" | "closed" | "spider"
<#
    token :s        = spaced(s):ts (!letter(s[0]) | !letter)          -> ts.join ' '
    spaced :s       -> for word in s.split ' '
                         MAlice.__super__.token.call(this, word)
  MAlice.matchAll(input, "program", undefined, ometaError)