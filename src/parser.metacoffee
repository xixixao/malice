module.exports = (OMeta, OMLib) -> parse: (input) ->
  {ometaError, Set} = OMLib

  join = (xs) ->
    xs.join ''

  concat = (xs...) ->
    (xs[0]?.concat xs[1..]...) ? []

  log = (xs...) ->
    console.log x for x in xs

  getKeywords = (usedTokens) ->
    keywords = new Set
    words = concat (token.split /\W/ for token in usedTokens)...
    (keywords.add word) for word in words when 'a' <= word[0] <= 'z' or 'A' <= word[0] <= 'Z'
    keywords.values()

  ometa MAlice
    program         = declarations:ds spaces end                      -> concat ['Program'], ds
    function        = (valueFunction | voidFunction):d                -> concat ['Function'], d
    valueFunction   = "The room"          identifier:i args:as
                      "contained a" type:returnType
                      block:b                                         -> [i, returnType, as, b]
    voidFunction    = "The looking-glass" identifier:i args:as
                      block:b                                         -> [i, 'void', as, b]
    args            = "(" listOf('argDeclaration', ','):as ")"        -> as
    argDeclaration  = eType:t identifier:n                            -> ['Argument', n, t]
    block           = "opened"
                      (declarations:ds statements:ss)? "closed"       -> concat ['Block'], ds, ss ? []
    declarations    = declaration*
    declaration     = function
                    | variable:v terminator                           -> v
    variable        = identifier:i "was a" type:t
                      (("of" expression:e) | "too")?                  -> ['Variable', i, t, e]
                    | identifier:i "had" expression:n type:t          -> ['Array', i, n, t]
    statements      = statement+
    statement       = (assignment | saying | call):s terminator       -> s
                    | "."                                             -> ['Skip']
                    | finding | question | conditional | loop
                    | block
    terminator      =  ("." | "," | "and" | "but" | "then")
    assignment      = assignable:x ("became" expression:e             -> ['Assignment', x, e]
                                   | "drank"                          -> ['Decrement', x]
                                   | "ate"                            -> ['Increment', x]
                                   )
    assignable      = arrayPiece | dereference
    saying          = expression:e ("said Alice" | "spoke")           -> ['Output', e]
    call            = identifier:i "(" expressionList:es ")"          -> ['Call', i, es]
    expressionList  = listOf('expression', ',')
    finding         = "Alice found" expression:e "."                  -> ['Return', e]
    question        = "what was" assignable:x "?"                     -> ['Input', x]
    conditional     = ("perhaps" | "either") "(" expression:c ") so"
                        statements:ss
                      orMaybe?:elif "because Alice was unsure which"  -> ['If', c, ss, elif]
    orMaybe         = "or maybe (" expression:c ") so"
                        statements:ss
                      orMaybe?:elif                                   -> ['If', c, ss, elif]
                    | "or"
                        statements:ss                                 -> ss
    loop            = "eventually (" expression:c ") because"
                        statements:ss "enough times"                  -> ['Until', c, ss]
    eType           = "spider" type:t                                 -> ['Spider', t]
                    | type
    type            = ("number" | "letter" | "sentence"):t            -> ['Type', t]
    expression      = or
    or              = or:b1  "||" and:b2                              -> ['Logic', '||', b1, b2]
                    | and
    and             = and:b1 "&&" negation:b2                         -> ['Logic', '&&', b1, b2]
                    | negation
    negation        = "!" negation:b                                  -> ['Logic', '!', b]
                    | comparison
    comparison      = comparison:e1 comparisonOp:op expression:e2     -> ['Compare', op, e1, e2]
                    | bitwiseOr
    comparisonOp    = "==" | ">=" | "<=" | "!=" | "<" | ">"
    bitwiseOr       = bitwiseOr:e1 "|" bitwiseXOr:e2                  -> ['Arithmetic', '|', e1, e2]
                    | bitwiseXOr
    bitwiseXOr      = bitwiseXOr:e1 "^" bitwiseAnd:e2                 -> ['Arithmetic', '^', e1, e2]
                    | bitwiseAnd
    bitwiseAnd      = bitwiseAnd:e1 "&" additive:e2                   -> ['Arithmetic', '&', e1, e2]
                    | additive
    additive        = additive:e1 additiveOp:op multiplicative:e2     -> ['Arithmetic', op, e1, e2]
                    | multiplicative
    additiveOp      = "+" | "-"
    multiplicative  = multiplicative:e1 multiplicativeOp:op unary:e2  -> ['Arithmetic', op, e1, e2]
                    | unary
    multiplicativeOp= "*" | "/" | "%"
    unary           = unaryOp:op unary:e                              -> ['Arithmetic', op, e]
                    | value
    unaryOp         = "~" | "-" | "+"
    value           = number | character | string
                    | arrayPiece | call | dereference
                    | "(" expression:e ")"                            -> e
    arrayPiece      = dereference:i "'s" expression:e "piece"         -> ['Element', i, e]
    dereference     = identifier:i                                    -> ['Dereference', i]
    number          = spaces digit+:ds                                -> ['Number', join ds]
    character       = spaces '\'' letter:c '\''                       -> ['Letter', c]
    string          = spaces '"' (!'"' anything)*:xs '"'              -> ['Sentence', join xs]
    identifier      = spaces (letter:x (letter | '_' | digit)*:xs     -> x + join xs):i
                      !{i in @keywords}                               -> i
    token :s        = spaced(s):ts (!letter(s[-1..]) | !letter)       -> ts.join ' '
    spaced :s                                                         -> for word in s.split ' '
                                                                           MAlice.__super__.token.call(this, word)
    initialize      -> @keywords = getKeywords @usedTokens

  MAlice.matchAll input, "program", undefined, ometaError
