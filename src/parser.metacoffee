module.exports = (OMeta, OMLib) -> parse: (input) ->
  {ometaError} = OMLib

  join = (xs) ->
    xs.join ''

  concat = (xs...) ->
    (xs[0]?.concat xs[1..]...) ? []

  ometa MAlice
    program        = declarations:ds spaces end                      -> concat ['Program'], ds
    function       = (valueFunction | voidFunction):d                -> concat ['Function'], d
    valueFunction  = "The room"          identifier:i args:as
                     "contained a" identifier:returnType
                     valueBlock:vb                                   -> concat [returnType, i, as], vb
    voidFunction   = "The looking-glass" identifier:i args:as
                     voidBlock:b                                     -> ['void', i, as, b]
    args           = "(" listOf('argDeclaration', ','):as ")"        -> as
    argDeclaration = type:t identifier:n                             -> [t, n]
    valueBlock     = openBlock:b finding:f 
                     <(statements finding)>*:dead "closed"           -> [(concat b, [f]), dead]
    voidBlock      = openBlock:b "closed"                            -> b
    openBlock      = "opened" declarations:ds statements:ss          -> concat ['Block'], ds, ss
    declarations   = declaration*
    declaration    = function | variable
    variable       = identifier:i "was a" type:t
                     (("of" expression:e) | "too")? terminator       -> ['Declaration', i, t, e]
    statements     = statement*
    statement      = (assignment | saying):s terminator              -> s
                   | conditional
                   | voidBlock
    conditional    =  "perhaps (" expression:cond ") so"
                     statements:ss orMaybe:elif
                     "because Alice was unsure which."               -> ['If', cond, ss, elif]
    elif           = "or maybe (" expression:cond ") so"
                     statements:ss orMaybe:elif                      -> ['If', cond, ss, elif]
                   | "or" statements
    assignment     = identifier:i ("became" expression:e             -> ['Assignment', i, e]
                                  | "drank"                          -> ['Increment', i]
                                  | "ate"                            -> ['Decrement', i]
                                  )
    saying         = expression:e ("said Alice" | "spoke")           -> ['Saying', e]
    finding        = "Alice found" expression:e terminator           -> ['Finding', e]
                   | valueBlock
    terminator     =  ("." | "," | "and" | "but" | "then")
    type           = "number"
                   | "letter"
                   | "sentence"
    expression     = identifier:i "("expressionList:es ")"           -> ['Call', i, es]
                   | bitwiseOr
    bitwiseOr      = bitwiseOr:e1 "|" bitwiseXOr:e2                  -> ['BOR', e1, e2]
                   | bitwiseXOr
    bitwiseXOr     = bitwiseXOr:e1 "^" bitwiseAnd:e2                 -> ['BXOR', e1, e2]
                   | bitwiseAnd
    bitwiseAnd     = bitwiseAnd:e1 "&" addition:e2                   -> ['BAND', e1, e2]
                   | addition
    addition       = addition:e1 "+" multiplication:e2               -> ['Plus', e1, e2]
                   | addition:e1 "-" multiplication:e2               -> ['Minus', e1, e2]
                   | multiplication
    multiplication = multiplication:e1 "*" negation:e2               -> ['Multiply', e1, e2]
                   | multiplication:e1 "/" negation:e2               -> ['Divide', e1, e2]
                   | multiplication:e1 "%" negation:e2               -> ['Modulo', e1, e2]
                   | negation
    negation       = "~" value:v                                     -> ['Negate', v]
                   | value
    value          = number | character | string | identifier
                   | "(" expression ")"
    expressionList = listOf('expression', ',')
    number         = spaces digit+:ds                                -> join ds
    character      = spaces '\'' letter:c '\''                       -> c
    string         = spaces '"' (!'"' anything)*:xs '"'              -> join xs
    identifier     = spaces letter:x (letter | '_')*:xs              -> x + join xs
    token :s       = ^token(s):t (!letter(s.charAt(0)) | !letter)    -> t

  MAlice.matchAll(input, "program", undefined, ometaError)