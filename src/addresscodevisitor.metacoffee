errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'

module.exports = (OMeta, OMLib) -> optimize: (addresscode) ->

  stack = addresscode.stack

  # Building Control Flow Graph
  # ---------------------------

  getNextInstruction = (from, at) ->
    loop
      next = from[++at]
      return [] if not next?
      return [next] if next[0] isnt "Label"


  # Generate firstAfter, the map from labels to first instructions following them
  # and initialize instruction properties
  firstAfter = {}
  for instruction, i in stack
    [type, label] = instruction
    next = getNextInstruction(stack, i)
    if type is "Label"
      firstAfter[label] = next[0]
      instruction.label = true
    else
      instruction.next = next
      instruction.using = []
      instruction.defines = []
      instruction.livein = []
      instruction.liveout = []

  # Fill information about instructions using firstAfter
  ometa MAliceCodeGeneration

    list        = trans*
    trans :node = visit(node, node)
    visit :node = [:t prepend([node]) apply(t)] -> node

    initialize
      ->  @moves = {}

    Label :node :name

    End :node :name
      -> node.next = []

    IfFalse :node :condition :jumpto if(node, condition, jumpto)
    IfTrue :node :condition :jumpto if(node, condition, jumpto)

    if :node :condition :jumpto
      ->  node.next.push firstAfter[jumpto]
          node.using.push condition

    Jump :node :to
      ->  node.next = [firstAfter[to]]

    Argument :node :name :type declaration(node, name, type)
    ArgumentPtr :node :name :type declaration(node, name, type)
    Variable :node :name :type declaration(node, name, type)
    Array :node :name :type :size declaration(node, name, type)

    declaration :node :name :type
      ->  node.defines.push name

    ArrayAccess :node :into :array :index assignment(node, into, array)
      ->  node.using.push index

    Decrement :node :variable assignment(node, variable, variable)
    Increment :node :variable assignment(node, variable, variable)

    Call :node :name :argumentCount

    Assignment :node :into :from assignment(node, into, from)
      -> (@moves[into] ?= []).push from
         (@moves[from] ?= []).push into

    assignment :node :into :from
      ->  node.defines.push into
          node.using.push from

    ValAssignment :node :into :value :type
      -> node.defines.push into

    Param :node :value
      ->  node.using.push value

    ParamPtr :node :value
      ->  node.using.push value

    CallAssignment :node :into :name :argumentCount
      ->  node.defines.push into

    ImmAssignment :node :into :operator :e1 anything?:e2
      -> node.defines.push into
         node.using.push e1
         node.using.push e2 if e2?

    ArrayAssignment :node :array :index :value
      ->  node.using.push array, index, value

    Return :node :result
      ->  node.using.push result

    Output :node :value :type
      ->  node.using.push value

    Read :node :into :type
      ->  node.defines.push into

  #global = MAliceCodeGeneration.matchAll addresscode.global, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
  #concat global,
  MAliceCodeGeneration.matchAll addresscode.stack, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"

  # Live Variable Analysis - Dataflow
  # ---------------------------------

  union = (arrays...) ->
    result = []
    for x in concat(arrays...) when not (x in result)
      result.push x
    result

  difference = (a, b) ->
    x for x in a when not (x in b)

  lastCounter = 0
  loop
    counter = 0
    for x in stack when not x.label?
      x.livein  = union x.using, difference x.liveout, x.defines
      x.liveout = union (next.livein for next in x.next)...
      counter += x.livein.length + x.liveout.length
    break if counter == lastCounter
    lastCounter = counter

  # Deriving Interference Graph
  # ---------------------------

#  for x in stack when not x.label?
#    log x
#    log "livein"
#    log x.livein
#    log "liveout"
#    log x.liveout

  variables = {}
  for x in stack when not x.label?
    for v in x.liveout
      variables[v] = union (variables[v] ? []), x.liveout

  for v, interferes of variables
    log v, interferes

  return addresscode