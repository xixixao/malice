errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'

module.exports = (OMeta, OMLib) -> optimize: (addresscode) ->

  nodes = addresscode.stack

  # Building Control Flow Graph
  # ---------------------------

  getNextInstruction = (nodes, at) ->
    loop
      next = nodes[++at]
      return [] if not next?
      next.include = true
      return [next] if next[0] isnt "Label"

  # Generate firstAfter, the map from labels to first instructions following them
  # and initialize instruction properties
  # Instruction properties will maintain the doubly linked control-flow graph
  firstAfter = {}
  for instruction, i in nodes
    [type, label] = instruction
    next = getNextInstruction(nodes, i)
    if type is "Label"
      firstAfter[label] = next[0]
      instruction.label = true
    else
      instruction.next = next
      instruction.prev = []
      instruction.using = []
      instruction.defines = []
      instruction.livein = []
      instruction.liveout = []
      if type is "End"
        instruction.next = []

  addDefines = (node, variables...) ->
    variables.map (v) -> node.defines.push [fromPointer v]

  addUsing = (node, variables...) ->
    variables.map (v) -> node.using.push [fromPointer(v), node]

  # Fill information about instructions using firstAfter
  moves = []
  ometa MAliceDataFlowAnalysis

    list        = trans*
    trans :node = visit(node, node)
    visit :node = [:t prepend([node]) apply(t)] -> node

    Label :node :name
    Begin :node

    End :node :name
      -> node.next = []

    IfFalse :node :condition :jumpto if(node, condition, jumpto)
    IfTrue :node :condition :jumpto if(node, condition, jumpto)

    if :node :condition :jumpto
      ->  node.next.push firstAfter[jumpto]
          addUsing node, condition

    Jump :node :to
      ->  node.next = [firstAfter[to]]

    Argument :node :name :type declaration(node, name)
    Array :node :name :type :size declaration(node, name)

    declaration :node :name
      ->  addDefines node, name

    ArrayAccess :node :into :array :index assignment(node, into, array)
      ->  addUsing node, index

    Decrement :node :variable assignment(node, variable, variable)
    Increment :node :variable assignment(node, variable, variable)

    Call :node :name :argumentCount

    Assignment :node :into :from assignment(node, into, from)
      ->  moves.push [fromPointer(into), fromPointer(from), node]

    assignment :node :into :from
      ->  addDefines node, into
          addUsing node, from

    ValAssignment :node :into :value :type
      ->  addDefines node, into

    Param :node :value
      ->  addUsing node, value

    ParamPop :node :variable
      ->  addDefines node, variable

    CallAssignment :node :into :name :argumentCount
      ->  addDefines node, into

    ImmAssignment :node :into :operator :e1 anything?:e2
      ->  addDefines node, into
          addUsing node, e1
          addUsing node, e2 if e2?
          if operator is "/"
            addDefines node, "$ax", "$dx"

    ArrayAssignment :node :array :index :value
      ->  addUsing node, array, index, value

    Return :node :result
      ->  addUsing node, result
          addDefines node, "$ax"

    Output :node :value :type cCall(node)
      ->  addUsing node, value

    Read :node :into :type cCall(node)
      ->  addDefines node, into

    cCall :node
      -> addDefines node, "$ax", "$dx", "$di", "$si"

  fromPointer = (value) ->
    if Array.isArray value then value[0] else value

  # Construct Control Flow Graph
  # ----------------------------

  #global = MAliceDataFlowAnalysis.matchAll addresscode.global, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
  #concat global,
  MAliceDataFlowAnalysis.matchAll nodes, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"

  createBackLinks = (nodes) ->
    for x in nodes when not x.label?
      for y in x.next
        y.prev.push x

  createBackLinks nodes

  removeNode = (node) ->
    for pred in node.prev
      pred.next.splice pred.next.indexOf(node), 1
      pred.next = union pred.next, node.next
    for succ in node.next
      succ.prev.splice succ.prev.indexOf(node), 1
      succ.prev = union succ.prev, node.prev


  # Live Variable Analysis - Dataflow
  # ---------------------------------

  union = (arrays...) ->
    result = []
    for x in concat(arrays...) when not (x in result)
      result.push x
    result

  difference = (a, b, different) ->
    different ?= (elA, elB) -> elA isnt elB
    x for x in a when b.every (y) -> different x, y

  solve = (nodes, fun) ->
    loop
      counter = 0
      for x in nodes when not x.label?
        counter += fun x
      break if counter == lastCounter
      lastCounter = counter
    return

  nodeDifference = (a, b) -> difference a, b, ([out], [def]) -> out isnt def

  liveness = (nodes) ->
    solve nodes, (x) ->
      x.livein  = union x.using, nodeDifference x.liveout, x.defines
      x.liveout = union (next.livein for next in x.next)...
      x.livein.length + x.liveout.length

  # Deriving Interference Graph
  # ---------------------------

  registers = [
    "$ax"
    "$bx"
    "$cx"
    "$dx"
    "$8"
    "$9"
    "$10"
    "$11"
    "$12"
    "$13"
    "$14"
    "$15"
    "$di"
    "$si"
  ]

  precolored = for reg, i in registers
    node = ["Register #{reg}"]
    node.liveout = registers.map (r) -> [r]
    node

  build = (nodes, precolored) ->
    graph = {}
    for x in concat precolored, nodes when not x.label?
      for [v] in x.liveout
        graph[v] = union (graph[v] ? []), x.liveout.map ([v2]) -> v2
    return graph

  categorize = (graph) ->
    for temp, interferes of graph
      delete interferes.moves
    moves = moves.filter ([a, b]) ->
      if graph[a] and graph[b]
        graph[a].moves = true
        graph[b].moves = true
        true
      else
        false
    return graph

  # Register Allocation - Graph Coloring
  # ------------------------------------

  remove = (temp, graph) ->
    interferes = graph[temp]
    for x in interferes
      graph[x] = graph[x]?.filter (t) -> t isnt temp
    delete graph[temp]

  simplify = (stack, graph, limit, canCoalesce = yes) ->
    for temp, interferes of graph when not (interferes.moves? or temp in registers)
      if interferes.length < limit
        stack.push [temp, interferes]
        #log "simplify-remove", temp
        remove temp, graph
        return coalesce stack, graph, limit
    if canCoalesce
      # Cannot simplify, but maybe can coalesce
      return coalesce stack, graph, limit, no
    else
      return freeze stack, graph, limit

  coalesce = (stack, graph, limit, canSimplify = yes) ->
    for [a, b, node], i in moves when graph[a]? and graph[b]?
      coalescable = graph[a].every (t) ->
        graph[t].length < limit or b in graph[t]
      if coalescable
        # Create new coalesced temporary
        newTemp = a + "," + b
        oldNames = [a, b]
        #log "coalescing into ", newTemp
        # Replace old temporaries with the new joined one
        for temp, interferes of graph
          graph[temp] = graph[temp].map (old) ->
            if old in oldNames then newTemp else old
        # Add new joined interference node and delete old nodes
        graph[newTemp] = union graph[a], graph[b]
        delete graph[a]
        delete graph[b]
        # Replace old temporaries in interference lists on the stack
        for [t, interference], si in stack
          stack[si] = [t, interference.map (old) ->
            if old in oldNames then newTemp else old
          ]
        # Replace old temporaries in moves
        for move in moves
          [c, d] = move
          move[0] = newTemp if c in oldNames
          move[1] = newTemp if d in oldNames
        # Delete old move node
        moves.splice i, 1
        # Check if the new node still moves
        categorize graph
        return simplify stack, graph, limit
    if canSimplify
      # Cannot coalesce, but maybe can simplify
      return coalesce stack, graph, limit, no
    else
      return freeze stack, graph, limit

  freeze = (stack, graph, limit) ->
    for temp, interferes of graph when interferes.moves?
      if interferes.length < limit
        delete interferes.moves
        moves = moves.filter (move) -> not (temp in move)
        return simplify stack, graph, limit
    return spill stack, graph, limit

  spill = (stack, graph, limit) ->
    for temp, interferes of graph when not temp in registers
      stack.push [temp, interferes]
      #log "spill", temp
      remove temp, graph
      return simplify stack, graph, limit
    return select stack, graph, limit


  select = (stack, graph, limit) ->
    colors = {}
    for reg in registers
      colors[reg] = registers
    while stack.length > 0
      [temp, interferes] = stack.pop()
      for color in registers
        if (interferes.every (x) -> colors[x] isnt color)
          colors[temp] = color
          break
      if color is limit
        log  "actual spill": temp
    return colors

  actualSpill = ->

  # Register Allocation - Update Data-flow Graph

  allocateRegisters = (nodes, coloring) ->

    # Returns whether some operand is unused, hence if the node is dead code
    replaceName = (node, index) ->
      temp = fromPointer node[index]
      if temp?
        return yes unless coloring[temp]?
        node[index] = coloring[temp]
      return no

    replaceNames = (node, number) ->
      [1..number].some (index) -> replaceName node, index

    # Split back coalesced temporaries
    for temp, register of coloring
      for t in temp.split ','
        coloring[t] = register

    for address in [nodes.length - 1..0]
      [code, operands...] = node = nodes[address]
      # Allocate registers
      switch code
        when 'Label', 'Begin', 'End', 'Jump', 'Call' then null
        when 'Assignment'
          replaceNames node, 2
          # Remove Assignment if useless
          [_, to, from] = node
          if to == from
            nodes.splice address, 1
        when 'ArrayAccess'
          replaceNames node, 3
        when 'ImmAssignment'
          # ['ImmAssignment', into, op, e1, e2?]
          [1, 3, 4].map (i) -> replaceName node, i
        else
           replaceNames node, 1

  # Dead-code Elimination
  # ---------------------
  shouldBeEliminated = (node, nodes) ->
    for defined in node.defines when not (fromPointer(defined) in registers)
      defined = fromPointer defined
      if (node.liveout.every ([used]) -> used isnt defined)
        for use in node.using
          for x in nodes when not x.label?
            for set in ['livein', 'liveout']
              x[set] = x[set].filter (xUse) -> xUse isnt use
        removeNode node
        log "Dead ", node
        return node.removed = true
    false

  deadCodeElimination = (nodes) ->
    for node in nodes when not node.removed?
      [code, operands...] = node
      switch code
        when 'Label', 'Begin', 'End', 'Jump', 'Call' then null
        when 'ParamPop'
          if shouldBeEliminated node, nodes
            node.useless = true
          return true
        else
          return true if shouldBeEliminated node, nodes
    return false

  removeDeadNodes = (nodes) ->
    nodes.filter (node) -> not node.removed? or node.useless?


  # Perform register allocation:
  # ----------------------------

  nodes = addresscode.stack
  liveness nodes
  while deadCodeElimination nodes
    liveness nodes
  nodes = removeDeadNodes nodes
  log nodes
  #for x, i in nodes
    #log i, x[0], x.removed, x.liveout
  interferenceGraph = categorize build nodes, precolored
  coloring = simplify [], interferenceGraph, registers.length
  log "coloring", coloring
  allocateRegisters nodes, coloring

  addresscode.stack = nodes

  return addresscode