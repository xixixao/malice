errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'

module.exports = (OMeta, OMLib) -> optimize: (instructions, namer) ->

  # Machine given registers
  registers = [
    "$ax"
    "$bx"
    "$cx"
    "$dx"
    "$8"
    "$9"
    "$10"
    "$11"
    "$12"
    "$13"
    "$14"
    "$15"
    "$di"
    "$si"
  ]
  # MAlice calling convention
  returnRegister = "$ax"
  calleeRegs = ["$bx", "$12", "$13", "$14", "$15"]
  callerRegs = ["$ax", "$cx", "$dx", "$di", "$si",
                "$8", "$9", "$10", "$11"]

  # C calling convention
  cReturnRegister = "$ax"
  cCallerSaveRegisters = ["$ax", "$cx", "$dx", "$di", "$si",
                          "$8", "$9", "$10", "$11"]


  # Building Control Flow Graph
  # ---------------------------
  fromPointer = (value) ->
    if Array.isArray value then value[0] else value

  fromToPointer = (value, func) ->
    isPointer = Array.isArray value
    newValue = func if isPointer then value[0] else value
    if isPointer then [newValue] else newValue

  controlFlowAnalysis = (instructions) ->
    getNextInstruction = (instructions, at) ->
      loop
        next = instructions[++at]
        return [] if not next?
        next.include = true
        return [next] if next[0] isnt "Label"

    # Initialize (potentially wipe out) instruction properties. Instruction
    # properties will maintain the doubly linked control-flow graph.
    # Generate firstAfter, the map from labels to first instructions following them
    firstAfter = {}
    for instruction, i in instructions
      [type, label] = instruction
      next = getNextInstruction(instructions, i)
      if type is "Label"
        firstAfter[label] = next[0]
        instruction.label = true
      else
        instruction.next = next
        instruction.prev = []
        instruction.using = []
        instruction.defines = []
        instruction.livein = []
        instruction.liveout = []
        if type is "End"
          instruction.next = []


    # Keep counts of uses and defines for spilling heuristic in register allocation
    defineCount = {}
    useCount = {}

    incrementDefine = (variable) ->
      defineCount[variable] = (defineCount[variable] ? 0) + 1
      variable

    incrementUse = (variable) ->
      useCount[variable] = (useCount[variable] ? 0) + 1
      variable

    addDefines = (node, variables...) ->
      variables.map (v) -> node.defines.push [incrementDefine(fromPointer v)]

    addUsing = (node, variables...) ->
      variables.map (v) -> node.using.push [incrementUse(fromPointer(v)), node]

    addLiveOut = (node, variables...) ->
      addDefines node, variables...
      variables.map (v) -> node.liveout.push [fromPointer v]

    # Fill information about instructions using firstAfter
    moves = []
    ometa MAliceControlFlowAnalysis

      list        = trans*
      trans :node = visit(node, node)
      visit :node = [:t prepend([node]) apply(t)] -> node

      Label :node :name
      Begin :node
        ->  addDefines node, calleeRegs...

      End :node :name
        ->  node.next = []
            addUsing node, calleeRegs...

      IfFalse :node :condition :jumpto if(node, condition, jumpto)
      IfTrue :node :condition :jumpto if(node, condition, jumpto)

      if :node :condition :jumpto
        ->  node.next.push firstAfter[jumpto]
            addUsing node, condition

      Jump :node :to
        ->  node.next = [firstAfter[to]]

      Argument :node :name :type declaration(node, name)
      Array :node :name :type :size declaration(node, name)
        ->  addUsing node, size, cReturnRegister

      declaration :node :name
        ->  addDefines node, name

      ArrayAccess :node :into :array :index :type assignment(node, into, array)
        ->  addUsing node, index, "$ax"
            addDefines node, cCallerSaveRegisters

      Decrement :node :variable assignment(node, variable, variable)
      Increment :node :variable assignment(node, variable, variable)

      Call :node :name :argumentCount
        ->  addLiveOut node, callerRegs...

      Push :node :name
        ->  addUsing node, name

      Pop :node :name
        ->  addDefines node, name

      Assignment :node :into :from assignment(node, into, from)
        ->  moves.push [fromPointer(into), fromPointer(from), node]

      assignment :node :into :from
        ->  addDefines node, into
            addUsing node, from

      ValAssignment :node :into :value :type
        ->  addDefines node, into

      Param :node :value
        ->  addUsing node, value

      ParamPop :node :variable
        ->  addDefines node, variable

      CallAssignment :node :into :name :argumentCount
        ->  addDefines node, into
            addLiveOut node, callerRegs...

      ImmAssignment :node :into :operator :e1 anything?:e2
        ->  addDefines node, into
            addUsing node, e1
            addUsing node, e2 if e2?
            if operator in ["/", "%"]
              addUsing node, "$ax", "$dx"
            else if operator in ['==', '!=', '<=', '>=', '<', '>']
              addUsing node, "$ax"

      ArrayAssignment :node :array :index :value :type
        ->  addUsing node, array, index, value, "$ax"
            addDefines node, cCallerSaveRegisters

      Return :node :result
        ->  #moves.push [returnRegister, result, node]
            addUsing node, result
            addUsing node, returnRegister

      Output :node :value :type cCall(node)
        ->  addUsing node, value

      Read :node :into :type cCall(node)
        ->  addDefines node, into

      cCall :node
        ->  addLiveOut node, cCallerSaveRegisters...

    # Construct Control Flow Graph
    # ----------------------------

    MAliceControlFlowAnalysis.matchAll instructions, "list", undefined, (m, i) ->
      console.error "ERROR while traversing three address code in control-flow optimizer"

    createBackLinks = (instructions) ->
      for x in instructions when not x.label?
        for y in x.next
          y.prev.push x
      return instructions

    # Control flow analysis finished
    return [
      createBackLinks instructions
      moves
      useCount
      defineCount
    ]

  removeNode = (node) ->
    for pred in node.prev
      pred.next.splice pred.next.indexOf(node), 1
      pred.next = union pred.next, node.next
    for succ in node.next
      succ.prev.splice succ.prev.indexOf(node), 1
      succ.prev = union succ.prev, node.prev


  # Live Variable Analysis - Dataflow
  # ---------------------------------

  union = (arrays...) ->
    result = []
    for x in concat(arrays...) when not (x in result)
      result.push x
    result

  difference = (a, b, different) ->
    different ?= (elA, elB) -> elA isnt elB
    x for x in a when b.every (y) -> different x, y

  solve = (nodes, fun) ->
    loop
      counter = 0
      for x in nodes when not x.label?
        counter += fun x
      break if counter == lastCounter
      lastCounter = counter
    return

  nodeDifference = (a, b) -> difference a, b, ([out], [def]) -> out isnt def

  liveness = (nodes) ->
    solve nodes, (x) ->
      x.livein  = union x.using, nodeDifference x.liveout, x.defines
      x.liveout = union x.liveout, (next.livein for next in x.next)...
      x.livein.length + x.liveout.length

  # Deriving Interference Graph
  # ---------------------------

  precolorRegisterNodes = ->
    for reg, i in registers
      node = ["Register #{reg}"]
      node.liveout = registers.map (r) -> [r]
      node

  build = (nodes, precolored) ->
    graph = {}
    for x in concat precolored, nodes when not x.label?
      for [v] in x.liveout
        graph[v] = union (graph[v] ? []), x.liveout.map ([v2]) -> v2
    return graph

  categorize = (graph, moves) ->
    for temp, interferes of graph
      delete interferes.move
    moves = moves.filter ([a, b]) ->
      if graph[a] and graph[b]
        graph[a].move = true
        graph[b].move = true
        true
      else
        false
    return graph

  # Register Allocation - Graph Coloring
  # ------------------------------------

  registerColoring = (nodes, locals, graph, moves, useCount, defineCount) ->
    # a stack holding nodes for coloring
    colorables = []

    limit = registers.length

    isRegister = (temp) ->
      temp.split(',').some (t) -> t in registers

    # Removes all occurences of temp from the interference graph
    remove = (temp) ->
      interferes = graph[temp]
      for x in interferes
        graph[x] = graph[x]?.filter (t) -> t isnt temp
      delete graph[temp]

    # Takes out a non-precolored, non-move-related node and pushes it onto colorables
    simplify = (canCoalesce = yes) ->
      for temp, interferes of graph when not (interferes.move? or temp in registers)
        if interferes.length < limit
          colorables.push [temp, interferes]
          log "simplify-remove", temp
          remove temp, graph
          return coalesce()
      if canCoalesce
        # Cannot simplify, but maybe can coalesce
        return coalesce no
      else
        return freeze()

    # Takes out some move which doesn't make the graph less colorable
    coalesce = (canSimplify = yes) ->
      for [a, b, node], i in moves when graph[a]? and graph[b]?
        #if a is b
        #  #delete this move
        #  simplify() #will loop forever
        #else

        if (a in graph[b]) or (a in registers and b in registers)
          for mi in [moves.length - 1..0] by -1
            [c, d] = move = moves[mi]
            if c in [a, b] and d in [a, b]
              moves.splice mi, 1
            categorize graph, moves
          simplify()
        else if not (a in registers or b in registers)
          log "nottregs", a, b
          significant = union(graph[a], graph[b]).filter (t) ->
            not (t in [a, b]) and graph[t].length >= limit
          coalescable = significant.length < limit
        else
          [r, notR] = if a in registers then [a, b] else [b, a]
          coalescable = graph[notR].every (t) ->
            t is notR or t in registers or graph[t].length < limit or r in graph[t]
        if coalescable
          # Create new coalesced temporary
          newTemp = a + "," + b
          log "coalescing", newTemp
          oldNames = [a, b]
          # Replace old temporaries with the new joined one
          for temp, interferes of graph
            graph[temp] = graph[temp].map (old) ->
              if old in oldNames then newTemp else old
          # Add new joined interference node and delete old nodes
          graph[newTemp] = union graph[a], graph[b]
          delete graph[a]
          delete graph[b]
          # Replace old temporaries in interference lists on the colorables
          for [t, interference], si in colorables
            colorables[si] = [t, interference.map (old) ->
              if old in oldNames then newTemp else old
            ]
          # Replace old temporaries in moves
          removedMoves = 0
          for mi in [moves.length - 1..0] by -1
            [c, d] = move = moves[mi]
            move[0] = newTemp if c in oldNames
            move[1] = newTemp if d in oldNames
            # Delete old move nodes
            if c in oldNames and d in oldNames
              moves.splice mi, 1
              removedMoves++
          # Update useCount and defineCount
          useCount[newTemp] = useCount[a] + useCount[b] - removedMoves
          defineCount[newTemp] = defineCount[a] + defineCount[b] - removedMoves
          # Check if the new node still moves
          categorize graph, moves
          return simplify()
      if canSimplify
        # Cannot coalesce, but maybe can simplify
        return coalesce no
      else
        return freeze()

    # Both coalescing and simplifying failed, we won't be able to coalesce some move
    freeze = ->
      for temp, interferes of graph when interferes.move?
        if interferes.length < limit
          delete interferes.move
          moves = moves.filter (move) -> not (temp in move)
          return simplify()
      return spill()

    # We ran out of possible colorable nodes, let's say some temporary will
    # be pushed and popped instead and push it onto colorables
    spill = ->
      # Get nodes available for spilling and sort them according to a heuristic
      # We use "Uses + Definitions / Number of Interferences"
      spills = for temp, interferes of graph when not (temp in registers)
        [temp, interferes]
      spills.sort ([aName, aInters], [bName, bInters]) ->
        (useCount[aName] ? 0) + (defineCount[aName] ? 0) / aInters.length -
        (useCount[bName] ? 0) + (defineCount[bName] ? 0) / bInters.length
      for [temp, interferes] in spills
        colorables.push [temp, interferes]
        log "spilling", temp
        remove temp, graph
        return simplify()
      return select()

    # We emptied the graph, let's rebuild and hope for the best!
    select = ->
      colors = {}
      actualSpills = []
      for reg in registers
        colors[reg] = reg
      while colorables.length > 0
        [temp, interferes] = colorables.pop()
        for t in temp.split ',' when t in registers
          colors[temp] = t
          break
        if not colors[temp]?
          for color in registers
            if (interferes.every (x) -> colors[x] isnt color)
              colors[temp] = color
              break
        log "color", colors[temp]
        # Our hopes vanished, there was no available color for this temporary
        if not colors[temp]?
          actualSpills.push temp
      if actualSpills.length is 0
        # Success, we are done!
        return [colors, nodes]
      else
        log "spilling actual", actualSpills
        actualSpill actualSpills

    # Coloring with current instructions failed, we need to introduce pushes and pops
    replaceOccurence = (locations, node, temp) ->
      unless locations[temp]
        locations[temp] = locals++
      newTemp = namer.newTemporary temp
      mapOverNode node, (t) -> if t is temp then newTemp else t
      newTemp

    actualSpill = (temps) ->
      locations = {}
      newInstructions = for node, i in nodes
        newNodes = [node]
        for fullTemp in temps
          for temp in fullTemp.split ','
            if node.defines?
              for [x] in node.defines when temp is x
                  newTemp = replaceOccurence locations, node, temp
                  log "changed", node
                  newNodes.push ['Push', newTemp]
            if node.using?
              for [x] in node.using when temp is x
                  log "uses", x, node.using, useCount[temp], i, nodes.length
                  newTemp =  replaceOccurence locations, node, temp
                  newNodes.unshift ['Pop', newTemp]
                  break
        newNodes
      return dataFlowAnalysis concat(newInstructions...), locals


    # Execute register coloring algorithm
    return simplify()

  mapOverNode = (node, func) ->
    [code, _] = node
    range = switch code
      when 'Label', 'Begin', 'End', 'Jump', 'Call' then []
      when 'Assignment' then [1..2]
      when 'ArrayAccess', 'ArrayAssignment' then [1..3]
      when 'Array' then [1, 3]
      when 'ImmAssignment' then [1, 3, 4] #[..., into, op, e1, e2?]
      else [1]
    range.map (i) ->
      node[i] = fromToPointer node[i], func if node[i]?

  # Register Allocation - Update Data-flow Graph
  # --------------------------------------------

  allocateRegisters = (nodes, coloring) ->


    # Split back coalesced temporaries
    for temp, register of coloring
      for t in temp.split ','
        coloring[t] = register

    # Allocate registers
    for address in [nodes.length - 1..0] by -1
      [code, operands...] = node = nodes[address]
      mapOverNode node, (temp) -> coloring[temp]
      if code is 'Assignment'
        # Remove Assignment if useless
        [_, to, from] = node
        if to == from
          nodes.splice address, 1

        #when 'Return'
        #  replaceNames node, 1
        #  [_, from] = node
        #  if from == returnRegister
        #    nodes.splice address, 1

    return nodes

  # Dead-code Elimination
  # ---------------------
  deadCodeElimination = (nodes) ->

    shouldBeEliminated = (node, nodes) ->
      for defined in node.defines when not (fromPointer(defined) in registers)
        defined = fromPointer defined
        if (node.liveout.every ([used]) -> used isnt defined)
          for use in node.using
            for x in nodes when not x.label?
              for set in ['livein', 'liveout']
                x[set] = x[set].filter (xUse) -> xUse isnt use
          removeNode node
          #log "Dead ", node
          return node.removed = true
      false

    analyzeDeadCode = (nodes) ->
      for node in nodes when not node.removed?
        [code, operands...] = node
        switch code
          when 'Label', 'Begin', 'End', 'Jump', 'Call' then null
          when 'ParamPop'
            if shouldBeEliminated node, nodes
              node.useless = true
              node.push true
              return true
          else
            return true if shouldBeEliminated node, nodes
      return false

    removeDeadNodes = (nodes) ->
      nodes.filter (node) -> not node.removed? or node.useless?

    while analyzeDeadCode nodes
      liveness nodes
    removeDeadNodes nodes


  # Perform All Phases of Dataflow Analysis
  # ---------------------------------------


  dataFlowAnalysis = (nodes, locals) ->
    [nodes, moves, useCount, defineCount] = controlFlowAnalysis nodes

    liveness nodes
#    for x, i in nodes
#      log i, x[0], x.using

    deadCodeElimination nodes

    interferenceGraph = categorize build(nodes, precolorRegisterNodes()), moves
    #log key, val for key, val of interferenceGraph when not (key in registers)
    #log "MOVES", moves
    return registerColoring nodes, locals, interferenceGraph, moves, useCount, defineCount
#    log "final coloring", coloring
    #log "coloring", coloring

  [coloring, nodes] = dataFlowAnalysis instructions, 0
  allocateRegisters nodes, coloring
