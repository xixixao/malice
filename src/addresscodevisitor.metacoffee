errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'

module.exports = (OMeta, OMLib) -> optimize: (addresscode) ->

  stack = addresscode.stack

  # Building Control Flow Graph
  # ---------------------------

  getNextInstruction = (from, at) ->
    loop
      next = from[++at]
      return [] if not next?
      next.include = true
      return [next] if next[0] isnt "Label"

  # Generate firstAfter, the map from labels to first instructions following them
  # and initialize instruction properties
  # Also performs simple dead code analysis
  firstAfter = {}
  for instruction, i in stack
    [type, label] = instruction
    next = getNextInstruction(stack, i)
    if type is "Label"
      firstAfter[label] = next[0]
      instruction.label = true
    else
      instruction.next = next
      instruction.using = []
      instruction.defines = []
      instruction.livein = []
      instruction.liveout = []
      if type is "End"
        instruction.next = []

  # Fill information about instructions using firstAfter
  moves = []
  ometa MAliceDataFlowAnalysis

    list        = trans*
    trans :node = visit(node, node)
    visit :node = [:t prepend([node]) apply(t)] -> node

    Label :node :name
    Begin :node

    End :node :name
      -> node.next = []

    IfFalse :node :condition :jumpto if(node, condition, jumpto)
    IfTrue :node :condition :jumpto if(node, condition, jumpto)

    if :node :condition :jumpto
      ->  node.next.push firstAfter[jumpto]
          node.using.push condition

    Jump :node :to
      ->  node.next = [firstAfter[to]]

    Argument :node :name :type declaration(node, name)
    Variable :node :name :type declaration(node, name)
    Array :node :name :type :size declaration(node, name)

    declaration :node :name
      ->  node.defines.push fromPointer name

    ArrayAccess :node :into :array :index assignment(node, into, array)
      ->  node.using.push index

    Decrement :node :variable assignment(node, variable, variable)
    Increment :node :variable assignment(node, variable, variable)

    Call :node :name :argumentCount

    Assignment :node :into :from assignment(node, into, from)
      ->  moves.push [fromPointer(into), fromPointer(from), node]

    assignment :node :into :from
      ->  node.defines.push fromPointer into
          node.using.push fromPointer from

    ValAssignment :node :into :value :type
      ->  node.defines.push into

    Param :node :value
      ->  node.using.push value

    ParamPop :node :variable
      ->  node.defines.push variable

    CallAssignment :node :into :name :argumentCount
      ->  node.defines.push into

    ImmAssignment :node :into :operator :e1 anything?:e2
      -> node.defines.push into
         node.using.push e1
         node.using.push e2 if e2?

    ArrayAssignment :node :array :index :value
      ->  node.using.push array, index, value

    Return :node :result
      ->  node.using.push result

    Output :node :value :type
      ->  node.using.push fromPointer value

    Read :node :into :type
      ->  node.defines.push into

  fromPointer = (value) ->
    if Array.isArray value then value[0] else value

  #global = MAliceDataFlowAnalysis.matchAll addresscode.global, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
  #concat global,
  MAliceDataFlowAnalysis.matchAll stack, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"





  # Live Variable Analysis - Dataflow
  # ---------------------------------

  union = (arrays...) ->
    result = []
    for x in concat(arrays...) when not (x in result)
      result.push x
    result

  difference = (a, b) ->
    x for x in a when not (x in b)

  solve = (nodes, fun) ->
    loop
      counter = 0
      for x in nodes when not x.label?
        counter += fun x
      break if counter == lastCounter
      lastCounter = counter
    return

  liveness = (nodes) ->
    solve nodes, (x) ->
      x.livein  = union x.using, difference x.liveout, x.defines
      x.liveout = union (next.livein for next in x.next)...
      x.livein.length + x.liveout.length

  # Deriving Interference Graph
  # ---------------------------

  build = (nodes) ->
    graph = {}
    for x in nodes when not x.label?
      for v in x.liveout
        graph[v] = union (graph[v] ? []), x.liveout
    log graph
    return graph

  categorize = (graph) ->
    log "categorize", graph, moves
    for temp, interferes of graph
      delete interferes.moves
    moves = moves.filter ([a, b]) ->
      if graph[a] and graph[b]
        graph[a].moves = true
        graph[b].moves = true
        true
      else
        false
    return

  # Register Allocation - Graph Coloring
  # ------------------------------------

  remove = (temp, graph) ->
    interferes = graph[temp]
    log "interferes", interferes
    for x in interferes
      graph[x] = graph[x]?.filter (t) -> t isnt temp
    delete graph[temp]

  simplify = (stack, graph, limit, canCoalesce = yes) ->
    log "simplify", graph
    for temp, interferes of graph when not interferes.moves?
      if interferes.length < limit
        stack.push [temp, interferes]
        log "simplify-remove", temp
        remove temp, graph
        return coalesce stack, graph, limit
    if canCoalesce
      # Cannot simplify, but maybe can coalesce
      return coalesce stack, graph, limit, no
    else
      return freeze stack, graph, limit

  coalesce = (stack, graph, limit, canSimplify = yes) ->
    log "coalesce", graph, moves
    for [a, b, node], i in moves
      coalescable = graph[a].every (t) ->
        graph[t].length < limit or b in graph[t]
      if coalescable
        # Create new coalesced temporary
        newTemp = a + "," + b
        # Replace old temporaries with the new joined one
        for temp, interferes of graph
          graph[temp] = graph[temp].map (x) ->
            if x in [a, b] then newTemp else x
        # Add new joined interference node and delete old nodes
        graph[newTemp] = union graph[a], graph[b]
        delete graph[a]
        delete graph[b]
        # Replace old temporaries in moves
        for move in moves
          [c, d] = move
          move[0] = newTemp if c in [a, b]
          move[1] = newTemp if d in [a, b]
        # Delete old move node
        moves.splice i, 1
        # Check if the new node still moves
        categorize graph
        return simplify stack, graph, limit
    if canSimplify
      # Cannot coalesce, but maybe can simplify
      return coalesce stack, graph, limit, no
    else
      return freeze stack, graph, limit

  freeze = (stack, graph, limit) ->
    for temp, interferes of graph when interferes.moves?
      if interferes.length < limit
        delete interferes.moves
        moves = moves.filter (move) -> not (temp in move)
        return simplify stack, graph, limit
    return spill stack, graph, limit

  spill = (stack, graph, limit) ->
    for temp, interferes of graph
      stack.push [temp, interferes]
      log "spill", temp
      remove temp, graph
      return simplify stack, graph, limit
    return select stack, graph, limit


  select = (stack, graph, limit) ->
    [temp, _] = stack.pop()
    colors = {}
    colors[temp] = 0
    log "stack", stack
    while stack.length > 0
      [temp, interferes] = stack.pop()
      for color in [0...limit]
        if (interferes.every (x) -> colors[x] isnt color)
          colors[temp] = color
          break
      if color is limit
        log  "actual spill": temp
    return colors

  actualSpill = ->

  # Register Allocation - Update Data-flow Graph

  allocateRegisters = (nodes, coloring) ->

    # Returns whether some operand is unused, hence if the node is dead code
    replaceNames = (node, number) ->
      for temp, i in node[1..number] by 1
        if !coloring[fromPointer temp]?
          return yes
        node[1 + i] = "$#{coloring[fromPointer temp]}"
      return no

    # Split back coalesced temporaries
    for temp, register of coloring
      for t in temp.split ','
        coloring[t] = register

    for address in [stack.length - 1..0]
      [code, operands...] = node = stack[address]
      # Allocate registers
      switch code
        when 'Label', 'Begin', 'End', 'Jump', 'Call' then null
        when 'Assignment'
          dead = replaceNames node, 2
          [_, to, from] = node
          dead or= to == from
        when 'ArrayAccess', 'ImmAssignment'
          dead = replaceNames node, 3
        else
          dead = replaceNames node, 1
          dead and= code isnt 'CallAssignment'
        # Remove node if dead code
      stack.splice address, 1 if dead


  # Perform register allocation:
  # ----------------------------

  nodes = addresscode.stack
  liveness nodes
  coloring = simplify [], build(nodes), 8
  allocateRegisters nodes, coloring

  return addresscode