errorHandler = require './errorprinter'
{concat, join} = require './metaCoffeeUtils'
{log} = require './utils'

module.exports = (OMeta, OMLib) -> optimize: (addresscode) ->

  stack = addresscode.stack

  # Building Control Flow Graph
  # ---------------------------

  getNextInstruction = (from, at) ->
    loop
      next = from[++at]
      return [] if not next?
      return [next] if next[0] isnt "Label"


  # Generate firstAfter, the map from labels to first instructions following them
  # and initialize instruction properties
  firstAfter = {}
  for instruction, i in stack
    [type, label] = instruction
    next = getNextInstruction(stack, i)
    if type is "Label"
      firstAfter[label] = next[0]
      instruction.label = true
    else
      instruction.next = next
      instruction.using = []
      instruction.defines = []
      instruction.livein = []
      instruction.liveout = []

  # Fill information about instructions using firstAfter
  moves = []
  ometa MAliceCodeGeneration

    list        = trans*
    trans :node = visit(node, node)
    visit :node = [:t prepend([node]) apply(t)] -> node

    initialize
      ->  moves = {}

    Label :node :name
    Begin :node

    End :node :name
      -> node.next = []

    IfFalse :node :condition :jumpto if(node, condition, jumpto)
    IfTrue :node :condition :jumpto if(node, condition, jumpto)

    if :node :condition :jumpto
      ->  node.next.push firstAfter[jumpto]
          node.using.push condition

    Jump :node :to
      ->  node.next = [firstAfter[to]]

    Argument :node :name :type declaration(node, name, type)
    Variable :node :name :type declaration(node, name, type)
    Array :node :name :type :size declaration(node, name, type)

    declaration :node :name :type
      ->  node.defines.push if Array.isArray name then name[0] else name

    ArrayAccess :node :into :array :index assignment(node, into, array)
      ->  node.using.push index

    Decrement :node :variable assignment(node, variable, variable)
    Increment :node :variable assignment(node, variable, variable)

    Call :node :name :argumentCount

    Assignment :node :into :from assignment(node, into, from)
      ->  if not Array.isArray(into) and not Array.isArray(from)
            moves.push [into, from, node]

    assignment :node :into :from
      ->  node.defines.push into unless Array.isArray into
          node.using.push from unless Array.isArray from

    ValAssignment :node :into :value :type
      ->  node.defines.push into

    Param :node :value
      ->  node.using.push value

    ParamPop :node :variable
      ->  node.defines.push variable

    CallAssignment :node :into :name :argumentCount
      ->  node.defines.push into

    ImmAssignment :node :into :operator :e1 anything?:e2
      -> node.defines.push into
         node.using.push e1
         node.using.push e2 if e2?

    ArrayAssignment :node :array :index :value
      ->  node.using.push array, index, value

    Return :node :result
      ->  node.using.push result

    Output :node :value :type
      ->  node.using.push if Array.isArray value then value[0] else value

    Read :node :into :type
      ->  node.defines.push into

  #global = MAliceCodeGeneration.matchAll addresscode.global, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"
  #concat global,
  MAliceCodeGeneration.matchAll addresscode.stack, "list", undefined, (m, i) -> console.error "ERROR while traversing AST in code generation"

  # Live Variable Analysis - Dataflow
  # ---------------------------------

  union = (arrays...) ->
    result = []
    for x in concat(arrays...) when not (x in result)
      result.push x
    result

  difference = (a, b) ->
    x for x in a when not (x in b)

  lastCounter = 0
  loop
    counter = 0
    for x in stack when not x.label?
      x.livein  = union x.using, difference x.liveout, x.defines
      x.liveout = union (next.livein for next in x.next)...
      counter += x.livein.length + x.liveout.length
    break if counter == lastCounter
    lastCounter = counter

  # Deriving Interference Graph
  # ---------------------------

  build = ->
    graph = {}
    for x in stack when not x.label?
      for v in x.liveout
        graph[v] = union (graph[v] ? []), x.liveout
    log graph
    return graph

  categorize = (graph) ->
    for temp, interferes of graph
      delete interferes.moves
    for [a, b] in moves
      graph[a].moves = true
      graph[b].moves = true
    return

  # Register Allocation - Graph Coloring
  # ------------------------------------

  remove = (temp, graph) ->
    interferes = graph[temp]
    log "interferes", interferes
    for x in interferes
      graph[x] = graph[x]?.filter (t) -> t isnt temp
    delete graph[temp]

  simplify = (stack, graph, limit) ->
    log "simplify", graph
    for temp, interferes of graph when not interferes.moves?
      if interferes.length < limit
        stack.push [temp, interferes]
        log "simplify-remove", temp
        remove temp, graph
        return coalesce stack, graph, limit
    return freeze stack, graph, limit

  coalesce = (stack, graph, limit) ->
    log "coalesce", graph
    for [a, b, node], i in moves
      log "cooool", a, b
      coalescable = graph[a].every (t) ->
        log "grapg of", t
        graph[t].length < limit or b in graph[t]
      if coalescable
        # Create new coalesced temporary
        newTemp = a + "," + b
        graph[newTemp] = union graph[a], graph[b]
        # Replace old temporaries with the new joined one
        for temp, interferes of graph
          graph[temp] = graph[temp].map (x) ->
            if x in [a, b] then newTemp else x
        # Delete old nodes
        delete graph[a]
        delete graph[b]
        # Replace old temporaries in moves
        for move in moves
          [c, d] = move
          move[0] = newTemp if c in [a, b]
          move[1] = newTemp if d in [a, b]
        # Delete old move node
        moves.splice i, 1
        # Check if the new node still moves
        categorize graph
        return simplify stack, graph, limit
    return freeze stack, graph, limit

  freeze = (stack, graph, limit) ->
    for temp, interferes of graph when interferes.moves?
      if interferes.length < limit
        delete interferes.moves
        moves = moves.filter (move) -> not (temp in move)
        return simplify stack, graph, limit
    return spill stack, graph, limit

  spill = (stack, graph, limit) ->
    for temp, interferes of graph
      stack.push [temp, interferes]
      log "spill", temp
      remove temp, graph
      return simplify stack, graph, limit
    return select stack, graph, limit


  select = (stack, graph, limit) ->
    [temp, _] = stack.pop()
    colors = {}
    colors[temp] = 0
    log "stack", stack
    while stack.length > 0
      [temp, interferes] = stack.pop()
      for color in [0...limit]
        if (interferes.every (x) -> colors[x] isnt color)
          colors[temp] = color
          break
      if color is limit
        log  "actual spill": temp
    return colors


  actualSpill = ->


  log simplify [], build(), 8

  return addresscode